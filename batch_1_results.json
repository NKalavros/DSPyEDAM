[
  {
    "name": "DESeq2",
    "description": "# Extracted content from DESeq2.md\n\n::: {.container-fluid .main-container}\n::: {#header}\n# Analyzing RNA-seq data with DESeq2 {#analyzing-rna-seq-data-with-deseq2 .title .toc-ignore}\n\n#### Michael I. Love, Simon Anders, and Wolfgang Huber {#michael-i.-love-simon-anders-and-wolfgang-huber .author}\n\n#### 05/11/2025 {#section .date}\n\n::: abstract\nAbstract\n\nA basic task in the analysis of count data from RNA-seq is the detection\nof differentially expressed genes. The count data are presented as a\ntable which reports, for each sample, the number of sequence fragments\nthat have been assigned to each gene. Analogous data also arise for\nother assay types, including comparative ChIP-Seq, HiC, shRNA screening,\nand mass spectrometry. An important analysis question is the\nquantification and statistical inference of systematic changes between\nconditions, as compared to within-condition variability. The package\nDESeq2 provides methods to test for differential expression by use of\nnegative binomial generalized linear models; the estimates of dispersion\nand logarithmic fold changes incorporate data-driven prior\ndistributions. This vignette explains the use of the package and\ndemonstrates typical workflows. [An RNA-seq\nworkflow](http://www.bioconductor.org/help/workflows/rnaseqGene/) on the\nBioconductor website covers similar material to this vignette but at a\nslower pace, including the generation of count matrices from FASTQ\nfiles. DESeq2 package version: 1.48.1\n:::\n:::\n\n::: {#TOC}\n-   [Standard workflow](#standard-workflow)\n    -   [Quick start](#quick-start)\n    -   [How to get help for DESeq2](#how-to-get-help-for-deseq2)\n    -   [Acknowledgments](#acknowledgments)\n    -   [Funding](#funding)\n    -   [Input data](#input-data)\n        -   [Why un-normalized counts?](#why-un-normalized-counts)\n        -   [The DESeqDataSet](#the-deseqdataset)\n        -   [Transcript abundance files and *tximport* /\n            *tximeta*](#transcript-abundance-files-and-tximport-tximeta)\n        -   [Tximeta for import with automatic\n            metadata](#tximeta-for-import-with-automatic-metadata)\n        -   [Count matrix input](#count-matrix-input)\n        -   [*htseq-count* input](#htseq-count-input)\n        -   [*SummarizedExperiment* input](#summarizedexperiment-input)\n        -   [Pre-filtering](#pre-filtering)\n        -   [Note on factor levels](#note-on-factor-levels)\n        -   [Collapsing technical\n            replicates](#collapsing-technical-replicates)\n        -   [About the pasilla dataset](#about-the-pasilla-dataset)\n    -   [Differential expression\n        analysis](#differential-expression-analysis)\n        -   [Log fold change shrinkage for visualization and\n            ranking](#log-fold-change-shrinkage-for-visualization-and-ranking)\n        -   [Speed-up and parallelization\n            thoughts](#speed-up-and-parallelization-thoughts)\n        -   [p-values and adjusted\n            p-values](#p-values-and-adjusted-p-values)\n        -   [Independent hypothesis\n            weighting](#independent-hypothesis-weighting)\n    -   [Exploring and exporting\n        results](#exploring-and-exporting-results)\n        -   [MA-plot](#ma-plot)\n        -   [Alternative shrinkage\n            estimators](#alternative-shrinkage-estimators)\n        -   [Plot counts](#plot-counts)\n        -   [More information on results\n            columns](#more-information-on-results-columns)\n        -   [Rich visualization and reporting of\n            results](#rich-visualization-and-reporting-of-results)\n        -   [Exporting results to CSV\n            files](#exporting-results-to-csv-files)\n    -   [Multi-factor designs](#multi-factor-designs)\n-   [Data transformations and\n    visualization](#data-transformations-and-visualization)\n    -   [Count data transformations](#count-data-transformations)\n        -   [Blind dispersion estimation](#blind-dispersion-estimation)\n        -   [Extracting transformed\n            values](#extracting-transformed-values)\n        -   [Variance stabilizing\n            transformation](#variance-stabilizing-transformation)\n        -   [Regularized log\n            transformation](#regularized-log-transformation)\n        -   [Effects of transformations on the\n            variance](#effects-of-transformations-on-the-variance)\n    -   [Data quality assessment by sample clustering and\n        visualization](#data-quality-assessment-by-sample-clustering-and-visualization)\n        -   [Heatmap of the count matrix](#heatmap-of-the-count-matrix)\n        -   [Heatmap of the sample-to-sample\n            distances](#heatmap-of-the-sample-to-sample-distances)\n        -   [Principal component plot of the\n            samples](#principal-component-plot-of-the-samples)\n-   [Variations to the standard\n    workflow](#variations-to-the-standard-workflow)\n    -   [Wald test individual steps](#wald-test-individual-steps)\n    -   [Control features for estimating size\n        factors](#control-features-for-estimating-size-factors)\n    -   [Contrasts](#contrasts)\n    -   [Interactions](#interactions)\n    -   [Time-series experiments](#time-series-experiments)\n    -   [Likelihood ratio test](#likelihood-ratio-test)\n    -   [Extended section on shrinkage\n        estimators](#extended-section-on-shrinkage-estimators)\n    -   [Recommendations for single-cell\n        analysis](#recommendations-for-single-cell-analysis)\n    -   [Approach to count outliers](#approach-to-count-outliers)\n    -   [Dispersion plot and fitting\n        alternatives](#dispersion-plot-and-fitting-alternatives)\n        -   [Local or mean dispersion\n            fit](#local-or-mean-dispersion-fit)\n        -   [Supply a custom dispersion\n            fit](#supply-a-custom-dispersion-fit)\n    -   [Independent filtering of\n        results](#independent-filtering-of-results)\n    -   [Tests of log2 fold change above or below a\n        threshold](#tests-of-log2-fold-change-above-or-below-a-threshold)\n    -   [Access to all calculated\n        values](#access-to-all-calculated-values)\n    -   [Sample-/gene-dependent normalization\n        factors](#sample-gene-dependent-normalization-factors)\n    -   [\"Model matrix not full rank\"](#model-matrix-not-full-rank)\n        -   [Linear combinations](#linear-combinations)\n        -   [Group-specific condition effects, individuals nested within\n            groups](#group-specific-condition-effects-individuals-nested-within-groups)\n        -   [Levels without samples](#levels-without-samples)\n-   [Theory behind DESeq2](#theory-behind-deseq2)\n    -   [The DESeq2 model](#the-deseq2-model)\n    -   [Changes compared to DESeq](#changes-compared-to-deseq)\n    -   [Methods changes since the 2014 DESeq2\n        paper](#methods-changes-since-the-2014-deseq2-paper)\n    -   [Count outlier detection](#count-outlier-detection)\n    -   [Contrasts](#contrasts-1)\n    -   [Expanded model matrices](#expanded-model-matrices)\n    -   [Independent filtering and multiple\n        testing](#independent-filtering-and-multiple-testing)\n        -   [Filtering criteria](#filtering-criteria)\n        -   [Why does it work?](#why-does-it-work)\n-   [Frequently asked questions](#frequently-asked-questions)\n    -   [How can I get support for\n        DESeq2?](#how-can-i-get-support-for-deseq2)\n    -   [Why are some *p* values set to\n        NA?](#why-are-some-p-values-set-to-na)\n    -   [How can I get unfiltered DESeq2\n        results?](#how-can-i-get-unfiltered-deseq2-results)\n    -   [How do I use VST or rlog data for differential\n        testing?](#how-do-i-use-vst-or-rlog-data-for-differential-testing)\n    -   [Why after VST are there still batches in the PCA\n        plot?](#why-after-vst-are-there-still-batches-in-the-pca-plot)\n    -   [Do normalized counts correct for variables in the\n        design?](#do-normalized-counts-correct-for-variables-in-the-design)\n    -   [Can I use DESeq2 to analyze paired\n        samples?](#can-i-use-deseq2-to-analyze-paired-samples)\n    -   [If I have multiple groups, should I run all together or split\n        into pairs of\n        groups?](#if-i-have-multiple-groups-should-i-run-all-together-or-split-into-pairs-of-groups)\n    -   [Can I run DESeq2 to contrast the levels of many\n        groups?](#can-i-run-deseq2-to-contrast-the-levels-of-many-groups)\n    -   [Can I use DESeq2 to analyze a dataset without\n        replicates?](#can-i-use-deseq2-to-analyze-a-dataset-without-replicates)\n    -   [How can I include a continuous covariate in the design\n        formula?](#how-can-i-include-a-continuous-covariate-in-the-design-formula)\n    -   [I ran a likelihood ratio test, but results() only gives me one\n        comparison.](#i-ran-a-likelihood-ratio-test-but-results-only-gives-me-one-comparison.)\n    -   [What are the exact steps performed by\n        DESeq()?](#what-are-the-exact-steps-performed-by-deseq)\n    -   [Is there an official Galaxy tool for\n        DESeq2?](#is-there-an-official-galaxy-tool-for-deseq2)\n    -   [I want to benchmark DESeq2 comparing to other DE\n        tools.](#i-want-to-benchmark-deseq2-comparing-to-other-de-tools.)\n    -   [I have trouble installing DESeq2 on\n        Ubuntu/Linux...](#i-have-trouble-installing-deseq2-on-ubuntulinux)\n-   [Session info](#session-info)\n-   [References](#references)\n:::\n\n::: {#standard-workflow .section .level1}\n# Standard workflow\n\n**Note:** if you use DESeq2 in published research, please cite:\n\n> Love, M.I., Huber, W., Anders, S. (2014) Moderated estimation of fold\n> change and dispersion for RNA-seq data with DESeq2. *Genome Biology*,\n> **15**:550.\n> [10.1186/s13059-014-0550-8](http://dx.doi.org/10.1186/s13059-014-0550-8)\n\nOther Bioconductor packages with similar aims are\n[edgeR](http://bioconductor.org/packages/edgeR),\n[limma](http://bioconductor.org/packages/limma),\n[DSS](http://bioconductor.org/packages/DSS),\n[EBSeq](http://bioconductor.org/packages/EBSeq), and\n[baySeq](http://bioconductor.org/packages/baySeq).\n\n::: {#quick-start .section .level2}\n## Quick start\n\nHere we show the most bas\n\n[Content truncated...]",
    "source": "vignette",
    "matches_above_threshold": [
      {
        "edam_id": "http://edamontology.org/data_0928",
        "edam_label": "Gene expression profile",
        "confidence_score": 0.9,
        "reasoning": "The DESeq2 package is primarily used for analyzing RNA-seq data to detect differentially expressed genes. This involves quantifying gene expression levels and performing statistical tests to identify significant changes in expression between conditions. The most relevant EDAM ontology term for this functionality is \"Gene expression profile,\" which refers to data quantifying the level of expression of multiple genes, typically derived from experiments like RNA-seq.",
        "validated": true
      },
      {
        "edam_id": "http://edamontology.org/data_3917",
        "edam_label": "Count matrix",
        "confidence_score": 0.9,
        "reasoning": "The DESeq2 package is primarily used for analyzing RNA-seq data to detect differentially expressed genes. It involves statistical methods to quantify and infer systematic changes between conditions. The most relevant EDAM ontology term from the provided list is \"Count matrix,\" which refers to a table of unnormalized values representing summarized read counts per genomic region, such as genes or transcripts. This aligns with DESeq2's functionality of analyzing count data from RNA-seq experiments.",
        "validated": true
      },
      {
        "edam_id": "http://edamontology.org/operation_3223",
        "edam_label": "Differential gene expression profiling",
        "confidence_score": 1.0,
        "reasoning": "The DESeq2 package is primarily used for analyzing RNA-seq data to detect differentially expressed genes. This involves quantifying gene expression levels and performing statistical inference to identify systematic changes between conditions. The most relevant EDAM ontology term for this functionality is \"Differential gene expression profiling,\" which specifically refers to identifying genes with significantly different expression levels between sample groups, aligning well with DESeq2's core purpose.",
        "validated": true
      },
      {
        "edam_id": "http://edamontology.org/topic_3170",
        "edam_label": "RNA-Seq",
        "confidence_score": 0.95,
        "reasoning": "The DESeq2 package is primarily used for analyzing RNA-seq data to detect differentially expressed genes. This involves high-throughput sequencing of cDNA to measure the RNA content (transcriptome) of a sample. The package description specifically mentions RNA-seq and the analysis of count data from RNA-seq experiments, which aligns directly with the EDAM ontology term \"RNA-Seq.\"",
        "validated": true
      }
    ],
    "suggested_new_category": {
      "suggested_label": "RNA-seq differential expression analysis",
      "suggested_category": "operation",
      "justification": "The suggested term \"RNA-seq differential expression analysis\" is needed to specifically describe operations that involve the analysis of RNA-seq data to identify differentially expressed genes. This term would encompass the unique methodologies used in DESeq2, such as the use of negative binomial generalized linear models and data-driven prior distributions for dispersion and fold change estimation. Existing terms like \"Differential gene expression profiling\" are too broad and do not specify the RNA-seq context or the statistical methods employed, which are critical for understanding the scope and application of DESeq2.",
      "similar_terms": [
        "Differential gene expression profiling",
        "RNA-seq analysis",
        "Gene expression analysis"
      ],
      "confidence_score": 0.85
    }
  },
  {
    "name": "limma",
    "description": "# Extracted content from intro.md\n\n::: {.container-fluid .main-container}\n::: {#header}\n# A brief introduction to limma {#a-brief-introduction-to-limma .title .toc-ignore}\n\n#### 23 October 2004 (last revised 11 June 2023) {#october-2004-last-revised-11-june-2023 .date}\n:::\n\n::: {#what-is-it .section .level1}\n# What is it?\n\nLimma is an R package for the analysis of gene expression data,\nespecially the use of linear models for analysing designed experiments\nand the assessment of differential expression. Limma provides the\nability to analyse comparisons between many RNA targets simultaneously\nin arbitrary complicated designed experiments. Empirical Bayesian\nmethods are used to provide stable results even when the number of\narrays is small. The normalization and background correction functions\nare provided for microarrays and similar technologies. The linear model\nand differential expression functions apply to a wide variety of gene\nexpression technologies including microarrays (single-channel or\ntwo-color), quantitative PCR, RNA-seq or proteomics.\n:::\n\n::: {#how-to-get-help .section .level1}\n# How to get help\n\nThe edgeR User's Guide is available by\n\n``` r\n> library(limma)\n> limmaRUsersGuide()\n```\n\nor alternatively from the [limma landing\npage](https://bioconductor.org/packages/limma).\n\nDocumentation for specific functions is available through the usual R\nhelp system, e.g., `?lmFit`. Further questions about the package should\nbe directed to the [Bioconductor support\nsite](https://support.bioconductor.org).\n:::\n\n::: {#further-reading .section .level1}\n# Further reading\n\nRitchie ME, Phipson B, Wu D, Hu Y, Law CW, Shi W, Smyth GK (2015). limma\npowers differential expression analyses for RNA-sequencing and\nmicroarray studies. *Nucleic Acids Research* 43, e47.\n[doi:10.1093/nar/gkv007](https://doi.org/10.1093/nar/gkv007)\n\nPhipson B, Lee S, Majewski IJ, Alexander WS, and Smyth GK (2016). Robust\nhyperparameter estimation protects against hypervariable genes and\nimproves power to detect differential expression. *Annals of Applied\nStatistics* 10, 946-963. [doi:10.1214/16-AOAS920](10.1214/16-AOAS920)\n\nLaw CW, Chen Y, Shi W, Smyth GK (2014). Voom: precision weights unlock\nlinear model analysis tools for RNA-seq read counts. Genome Biology 15,\nR29.\n[doi:10.1186/gb-2014-15-2-r29](https://doi.org/10.1186/gb-2014-15-2-r29).\nSee also the Preprint Version at\n<https://gksmyth.github.io/pubs/VoomPreprint.pdf> incorporating some\nnotational corrections.\n\nLaw CW, Alhamdoosh M, Su S, Dong X, Tian L, Smyth GK, Ritchie ME (2016).\nRNA-seq analysis is easy as 1-2-3 with limma, Glimma and edgeR.\n*F1000Research* 5, 1408.\n[doi:10.12688/f1000research.9005.3](https://doi.org/10.12688/f1000research.9005.3)\n\nLaw CW, Zeglinski K, Dong X, Alhamdoosh M, Smyth GK, Ritchie ME (2020).\nA guide to creating design matrices for gene expression experiments.\n*F1000Research* 9, 1444.\n[doi:10.12688/f1000research.27893.1](https://doi.org/10.12688/f1000research.27893.1)\n:::\n:::\n",
    "source": "vignette",
    "matches_above_threshold": [
      {
        "edam_id": "http://edamontology.org/data_0928",
        "edam_label": "Gene expression profile",
        "confidence_score": 0.9,
        "reasoning": "The package \"limma\" is primarily used for the analysis of gene expression data, particularly focusing on differential expression analysis using linear models. It is applicable to various gene expression technologies, including microarrays and RNA-seq. The most relevant EDAM ontology term from the candidate list is \"Gene expression profile,\" which pertains to data quantifying the level of expression of multiple genes, typically derived from microarray experiments. This aligns well with the core functionality of the limma package.",
        "validated": true
      },
      {
        "edam_id": "http://edamontology.org/operation_0314",
        "edam_label": "Gene expression profiling",
        "confidence_score": 0.9,
        "reasoning": "The limma package is primarily used for the analysis of gene expression data, particularly focusing on differential expression analysis using linear models. It supports various gene expression technologies, including microarrays and RNA-seq. The candidate term \"Gene expression profiling\" aligns well with limma's functionality, as it involves measuring the activity of multiple genes to understand biological functions, which is a core aspect of what limma facilitates.",
        "validated": true
      },
      {
        "edam_id": "http://edamontology.org/operation_3223",
        "edam_label": "Differential gene expression profiling",
        "confidence_score": 0.95,
        "reasoning": "The package \"limma\" is primarily focused on the analysis of gene expression data, particularly through the use of linear models and differential expression analysis. It is applicable to various gene expression technologies, including microarrays and RNA-seq. The candidate term \"Differential gene expression profiling\" directly relates to the core functionality of limma, which is to identify genes with significantly different expression levels between sample groups. This makes it the most relevant EDAM ontology term for the package.",
        "validated": true
      },
      {
        "edam_id": "http://edamontology.org/topic_3518",
        "edam_label": "Microarray experiment",
        "confidence_score": 0.9,
        "reasoning": "The package \"limma\" is primarily focused on the analysis of gene expression data, particularly using linear models for differential expression analysis. It supports various gene expression technologies, including microarrays and RNA-seq. Among the candidate terms, \"Microarray experiment\" is the most relevant as it directly relates to one of the key technologies that limma is designed to analyze. The package provides tools for normalization, background correction, and differential expression analysis, which are essential components of microarray experiments.",
        "validated": true
      }
    ],
    "suggested_new_category": {
      "suggested_label": "Gene expression analysis using linear models",
      "suggested_category": "operation",
      "justification": "The suggested term \"Gene expression analysis using linear models\" is needed because limma's core functionality revolves around the application of linear models to analyze gene expression data. This includes handling complex experimental designs and providing stable results through empirical Bayesian methods. Existing terms like \"Differential gene expression profiling\" do not specifically address the use of linear models, which is a significant aspect of limma's approach. Therefore, a new term would better categorize tools and methods that focus on this specific analytical technique.",
      "similar_terms": [
        "Differential gene expression profiling",
        "Gene expression analysis",
        "Microarray data analysis"
      ],
      "confidence_score": 0.85
    }
  },
  {
    "name": "AnnotationDbi",
    "description": "# Extracted content from AnnotationDbi.pdf\n\n# How to use bimaps from the \".db\" annota- tion packages\n\n### Marc Carlson, Herv\u00e9 Pag\u00e8s, Seth Falcon, Nianhua Li\n\n#### April 15, 2025\n\n##### NOTE The \u2018bimap\u2019 interface to annotation resources is not recommend; instead, use the approach in the vignette Introduction To Bioconductor Annotation Packages.\n\n## 1 Introduction\n\n#### 1.0.1 Purpose\n\n##### AnnotationDbi is used primarily to create mapping objects that allow easy access from R to underlying annotation databases. As such, it acts as the R interface for all the standard annotation packages. Underlying each AnnotationDbi supported anno- tation package is at least one (and often two) annotation databases. AnnotationDbi also provides schemas for theses databases. For each supported model organism, a standard gene centric database is maintained from public sources and is packaged up as an appropriate organism or \"org\" package.\n\n#### 1.0.2 Database Schemas\n\n##### For developers, a lot of the benefits of having the information loaded into a real database will require some knowledge about the database schema. For this reason the schemas that were used in the creation of each database type are included in AnnotationDbi. The currently supported schemas are listed in the DBschemas direc- tory of AnnotationDbi. But it is also possible to simply print out the schema that a package is currently using by using its \"_dbschema\" method.\n\n There is one schema/database in each kind of package. These schemas specify which tables and indices will be present for each package of that type. The schema that a particular package is using is also listed when you type the name of the package as a function to obtain quality control information.\n\n The code to make most kinds of the new database packages is also included in AnnotationDbi. Please see the vignette on SQLForge for more details on how to make additional database packages.\n\n\n-----\n\n##### How to use bimaps from the .db annotation packages\n\n#### 1.0.3 Internal schema Design of org packages\n\n##### The current design of the organism packages is deliberately simple and gene centric. Each table in the database contains a unique kind of information and also an internal identifier called _id. The internal _id has no meaning outside of the context of a single database. But _id does connect all the data within a single database.\n\n As an example if we wanted to connect the values in the genes table with the values in the kegg table, we could simply join the two tables using the internal _id column. It is very important to note however that _id does not have any absolute significance. That is, it has no meaning outside of the context of the database where it is used. It is tempting to think that an _id could have such significance because within a single database, it looks and behaves similarly to an entrez gene ID. But _id is definitely NOT an entrez gene ID. The entrez gene IDs are in another table entirely, and can be connected to using the internal _id just like all the other meaningful information inside these databases. Each organism package is centered around one type of gene identifier. This identifier is found as the gene_id field in the genes table and is both the central ID for the database as well as the foreign key that chip packages should join to.\n\n The chip packages are \u2019lightweight\u2019, and only contain information about the basic probe to gene mapping. You might wonder how such packages can provide access to all the other information that they do. This is possible because all the other data provided by chip packages comes from joins that are performed by AnnotationDbi behind the scenes at run time. All chip packages have a dependency on at least one organism package. The name of the organism package being depended on can be found by looking at its \"ORGPKG\" value. To learn about the schema from the appropriate organism package, you will need to look at the \"_dbschema\" method for that package. In the case of the chip packages, the gene_id that in these packages is mapped to the probe_ids, is used as a foreign key to the appropriate organism package.\n\n Specialized packages like the packages for GO and KEGG, will have their own schemas but will also adhere to the use of an internal _id for joins between their tables. As with the organism packages, this _id is not suitable for use as a foreign key.\n\n For a complete listing of the different schemas used by various packages, users can use the available.dbschemas function. This list will also tell you which model organisms are supported.\n\n```\nlibrary(DBI)\nlibrary(org.Hs.eg.db)\n## Loading required package: AnnotationDbi\n## Loading required package: stats4\n## Loading required package: BiocGenerics\n## Loading required package: generics\n\n```\n\n-----\n\n##### How to use bimaps from the .db annotation packages\n\n```\n##\n## Attaching package: \u2019generics\u2019\n## The following objects are masked from \u2019package:base\u2019:\n##\n## as.difftime, as.factor, as.ordered, intersect, is.element,\n## setdiff, setequal, union\n##\n## Attaching package: \u2019BiocGenerics\u2019\n## The following objects are masked from \u2019package:stats\u2019:\n##\n## IQR, mad, sd, var, xtabs\n## The following objects are masked from \u2019package:base\u2019:\n##\n## Filter, Find, Map, Position, Reduce, anyDuplicated, aperm,\n## append, as.data.frame, basename, cbind, colnames, dirname,\n## do.call, duplicated, eval, evalq, get, grep, grepl, is.unsorted,\n## lapply, mapply, match, mget, order, paste, pmax, pmax.int, pmin,\n## pmin.int, rank, rbind, rownames, sapply, saveRDS, table, tapply,\n## unique, unsplit, which.max, which.min\n## Loading required package: Biobase\n## Welcome to Bioconductor\n##\n## Vignettes contain introductory material; view with\n## \u2019browseVignettes()\u2019. To cite Bioconductor, see\n## \u2019citation(\"Biobase\")\u2019, and for packages \u2019citation(\"pkgname\")\u2019.\n## Loading required package: IRanges\n## Loading required package: S4Vectors\n##\n## Attaching package: \u2019S4Vectors\u2019\n## The following object is masked from \u2019package:utils\u2019:\n##\n## findMatches\n## The following objects are masked from \u2019package:base\u2019:\n##\n## I, expand.grid, unname\n##\nlibrary(AnnotationForge)\navailable.dbschemas()\n\n```\n\n-----\n\n##### How to use bimaps from the .db annotation packages\n\n## 2 Examples\n\n#### 2.0.1 Basic information\n\n##### The AnnotationDbi package provides an interface to SQLite-based annotation pack- ages. Each SQLite-based annotation package (identified by a \u201c.db\u201d suffix in the package name) contains a number of AnnDbBimap objects in place of the environ- ment objects found in the old-style environment-based annotation packages. The API provided by AnnotationDbi allows you to treat the AnnDbBimap objects like environment instances. For example, the functions [[, get, mget, and ls all behave the same as they did with the older environment based annotation packages. In addition, new methods like [, toTable, subset and others provide some additional flexibility in accessing the annotation data.\n\n```\nlibrary(hgu95av2.db)\n##\n\n```\n\n##### The same basic set of objects is provided with the db packages:\n\n```\nls(\"package:hgu95av2.db\")\n## [1] \"hgu95av2\" \"hgu95av2.db\"\n## [3] \"hgu95av2ACCNUM\" \"hgu95av2ALIAS2PROBE\"\n## [5] \"hgu95av2CHR\" \"hgu95av2CHRLENGTHS\"\n## [7] \"hgu95av2CHRLOC\" \"hgu95av2CHRLOCEND\"\n## [9] \"hgu95av2ENSEMBL\" \"hgu95av2ENSEMBL2PROBE\"\n## [11] \"hgu95av2ENTREZID\" \"hgu95av2ENZYME\"\n## [13] \"hgu95av2ENZYME2PROBE\" \"hgu95av2GENENAME\"\n## [15] \"hgu95av2GO\" \"hgu95av2GO2ALLPROBES\"\n## [17] \"hgu95av2GO2PROBE\" \"hgu95av2MAP\"\n## [19] \"hgu95av2MAPCOUNTS\" \"hgu95av2OMIM\"\n## [21] \"hgu95av2ORGANISM\" \"hgu95av2ORGPKG\"\n## [23] \"hgu95av2PATH\" \"hgu95av2PATH2PROBE\"\n## [25] \"hgu95av2PFAM\" \"hgu95av2PMID\"\n## [27] \"hgu95av2PMID2PROBE\" \"hgu95av2PROSITE\"\n## [29] \"hgu95av2REFSEQ\" \"hgu95av2SYMBOL\"\n## [31] \"hgu95av2UNIPROT\" \"hgu95av2[_]dbInfo\"\n## [33] \"hgu95av2[_]dbconn\" \"hgu95av2[_]dbfile\"\n## [35] \"hgu95av2[_]dbschema\"\n\n```\n\n##### Exercise 1 Start an R session and use the library function to load the hgu95av2.db software package. Use search() to see that an organism package was also loaded and then use the approriate \"_dbschema\" methods to the schema for the hgu95av2.db and org.Hs.eg.db packages.\n\n\n-----\n\n##### How to use bimaps from the .db annotation packages\n\n It is possible to call the package name as a function to get some QC information about it.\n\n```\nqcdata = capture.output(hgu95av2())\nhead(qcdata, 20)\n## [1] \"Quality control information for hgu95av2:\"\n## [2] \"\"\n## [3] \"\"\n## [4] \"This package has the following mappings:\"\n## [5] \"\"\n## [6] \"hgu95av2ACCNUM has 12625 mapped keys (of 12625 keys)\"\n## [7] \"hgu95av2ALIAS2PROBE has 37476 mapped keys (of 261311 keys)\"\n## [8] \"hgu95av2CHR has 11683 mapped keys (of 12625 keys)\"\n## [9] \"hgu95av2CHRLENGTHS has 595 mapped keys (of 711 keys)\"\n## [10] \"hgu95av2CHRLOC has 11637 mapped keys (of 12625 keys)\"\n## [11] \"hgu95av2CHRLOCEND has 11637 mapped keys (of 12625 keys)\"\n## [12] \"hgu95av2ENSEMBL has 11609 mapped keys (of 12625 keys)\"\n## [13] \"hgu95av2ENSEMBL2PROBE has 10016 mapped keys (of 42248 keys)\"\n## [14] \"hgu95av2ENTREZID has 11683 mapped keys (of 12625 keys)\"\n## [15] \"hgu95av2ENZYME has 2137 mapped keys (of 12625 keys)\"\n## [16] \"hgu95av2ENZYME2PROBE has 785 mapped keys (of 975 keys)\"\n## [17] \"hgu95av2GENENAME has 11683 mapped keys (of 12625 keys)\"\n## [18] \"hgu95av2GO has 11475 mapped keys (of 12625 keys)\"\n## [19] \"hgu95av2GO2ALLPROBES has 20621 mapped keys (of 22286 keys)\"\n## [20] \"hgu95av2GO2PROBE has 15988 mapped keys (of 18640 keys)\"\n\n```\n\n##### Alternatively, you can get similar information on how many items are in each of the provided maps by looking at the MAPCOUNTs:\n\n```\nhgu95av2MAPCOUNTS\n\n```\n\n##### To demonstrate the environment API, we\u2019ll start with a random sample of probe set IDs.\n\n```\nall[_]probes <- ls(hgu95av2ENTREZID)\nlength(all[_]probes)\n## [1] 12625\nset.seed(0xa1beef)\nprobes <- sample(all[_]probes, 5)\nprobes\n## [1] \"39758[_]f[_]at\" \"34055[_]at\" \"34045[_]at\" \"38348[_]at\" \"40584[_]at\"\n\n```\n\n##### The usual ways of accessing a\n\n[Content truncated...]",
    "source": "vignette",
    "matches_above_threshold": [
      {
        "edam_id": "http://edamontology.org/data_0954",
        "edam_label": "Database cross-mapping",
        "confidence_score": 0.9,
        "reasoning": "The AnnotationDbi package is primarily concerned with creating mapping objects that facilitate access to annotation databases, which aligns with the concept of \"Database cross-mapping.\" This term refers to the mapping of accession numbers or identifiers between databases, which is a core functionality of AnnotationDbi as it provides an interface to various annotation databases and supports cross-referencing between them.",
        "validated": true
      },
      {
        "edam_id": "http://edamontology.org/data_3509",
        "edam_label": "Ontology mapping",
        "confidence_score": 0.8,
        "reasoning": "The AnnotationDbi package is primarily concerned with creating mapping objects that facilitate access to annotation databases, particularly for gene-centric data. It provides an interface to SQLite-based annotation packages and includes schemas for these databases. The package's functionality aligns with the concept of \"Ontology mapping,\" which involves mapping textual terms or phrases to ontology concepts. This is because AnnotationDbi essentially maps gene identifiers and other biological data to structured database entries, which is a form of ontology mapping.",
        "validated": true
      },
      {
        "edam_id": "http://edamontology.org/topic_0102",
        "edam_label": "Mapping",
        "confidence_score": 0.9,
        "reasoning": "The AnnotationDbi package is primarily used to create mapping objects that facilitate access to annotation databases from R. It acts as an interface for annotation packages, providing schemas for databases and supporting gene-centric databases for model organisms. The package's functionality aligns with the concept of \"Mapping\" in the EDAM ontology, which involves mapping properties to positions on a biological entity, such as a molecular sequence or structure. This includes resources that aim to identify, map, or analyze genetic markers in DNA sequences, which is consistent with the purpose of AnnotationDbi in managing and accessing annotation data.",
        "validated": true
      },
      {
        "edam_id": "http://edamontology.org/topic_3071",
        "edam_label": "Biological databases",
        "confidence_score": 0.9,
        "reasoning": "The AnnotationDbi package is primarily concerned with providing an interface to annotation databases, allowing for the creation and management of mapping objects that facilitate access to these databases. This aligns closely with the concept of \"Biological databases,\" which involves the development and use of architectures, policies, practices, and procedures for managing data. The package's focus on database schemas, mapping, and integration of biological data fits well within this ontology term.",
        "validated": true
      }
    ],
    "suggested_new_category": {
      "suggested_label": "Annotation database interface",
      "suggested_category": "operation",
      "justification": "The AnnotationDbi package provides a unique functionality that is not adequately covered by existing EDAM terms. It acts as an interface to annotation databases, allowing users to access and manage these databases through R. This includes the use of database schemas, mappings, and the ability to perform operations such as querying and retrieving data. The existing term \"Database cross-mapping\" does not fully encompass the broader functionality of providing an interface to these databases. Therefore, a new term \"Annotation database interface\" is suggested to better describe this operation.",
      "similar_terms": [
        "Database cross-mapping",
        "Query and retrieval",
        "Annotation"
      ],
      "confidence_score": 0.7
    }
  },
  {
    "name": "GEOquery",
    "description": "# Extracted content from GEOquery.md\n\n::: {.container-fluid .main-container}\n::: {#header}\n# Using the GEOquery Package {#using-the-geoquery-package .title .toc-ignore}\n\n#### Sean Davis {#sean-davis .author}\n\n#### September 21, 2014 {#september-21-2014 .date}\n:::\n\n::: {#TOC}\n-   [[1]{.toc-section-number} Overview of GEO](#overview-of-geo)\n    -   [[1.1]{.toc-section-number} Platforms](#platforms)\n    -   [[1.2]{.toc-section-number} Samples](#samples)\n    -   [[1.3]{.toc-section-number} Series](#series)\n    -   [[1.4]{.toc-section-number} Datasets](#datasets)\n-   [[2]{.toc-section-number} Getting Started using\n    GEOquery](#getting-started-using-geoquery)\n-   [[3]{.toc-section-number} GEOquery Data\n    Structures](#geoquery-data-structures)\n    -   [[3.1]{.toc-section-number} The GDS, GSM, and GPL\n        classes](#the-gds-gsm-and-gpl-classes)\n    -   [[3.2]{.toc-section-number} The GSE class](#the-gse-class)\n-   [[4]{.toc-section-number} Converting to BioConductor ExpressionSets\n    and limma\n    MALists](#converting-to-bioconductor-expressionsets-and-limma-malists)\n    -   [[4.1]{.toc-section-number} Getting GSE Series Matrix files as\n        an\n        ExpressionSet](#getting-gse-series-matrix-files-as-an-expressionset)\n    -   [[4.2]{.toc-section-number} Converting GDS to an\n        ExpressionSet](#converting-gds-to-an-expressionset)\n    -   [[4.3]{.toc-section-number} Converting GDS to an\n        MAList](#converting-gds-to-an-malist)\n    -   [[4.4]{.toc-section-number} Converting GSE to an\n        ExpressionSet](#converting-gse-to-an-expressionset)\n-   [[5]{.toc-section-number} Accessing Raw Data from\n    GEO](#accessing-raw-data-from-geo)\n-   [[6]{.toc-section-number} Use Cases](#use-cases)\n    -   [[6.1]{.toc-section-number} Getting all Series Records for a\n        Given\n        Platform](#getting-all-series-records-for-a-given-platform)\n-   [[7]{.toc-section-number} Conclusion](#conclusion)\n    -   [[7.1]{.toc-section-number} Citing GEOquery](#citing-geoquery)\n    -   [[7.2]{.toc-section-number} Reporting problems or\n        bugs](#reporting-problems-or-bugs)\n-   [[8]{.toc-section-number} Session info](#session-info)\n:::\n\n::: {#overview-of-geo .section .level1}\n# [1]{.header-section-number} Overview of GEO\n\nThe NCBI Gene Expression Omnibus (GEO) serves as a public repository for\na wide range of high-throughput experimental data. These data include\nsingle and dual channel microarray-based experiments measuring mRNA,\ngenomic DNA, and protein abundance, as well as non-array techniques such\nas serial analysis of gene expression (SAGE), mass spectrometry\nproteomic data, and high-throughput sequencing data.\n\nAt the most basic level of organization of GEO, there are four basic\nentity types. The first three (Sample, Platform, and Series) are\nsupplied by users; the fourth, the dataset, is compiled and curated by\nGEO staff from the user-submitted data. See [the GEO home\npage](https://www.ncbi.nlm.nih.gov/geo/) for more information.\n\n::: {#platforms .section .level2}\n## [1.1]{.header-section-number} Platforms\n\nA Platform record describes the list of elements on the array (e.g.,\ncDNAs, oligonucleotide probesets, ORFs, antibodies) or the list of\nelements that may be detected and quantified in that experiment (e.g.,\nSAGE tags, peptides). Each Platform record is assigned a unique and\nstable GEO accession number (GPLxxx). A Platform may reference many\nSamples that have been submitted by multiple submitters.\n:::\n\n::: {#samples .section .level2}\n## [1.2]{.header-section-number} Samples\n\nA Sample record describes the conditions under which an individual\nSample was handled, the manipulations it underwent, and the abundance\nmeasurement of each element derived from it. Each Sample record is\nassigned a unique and stable GEO accession number (GSMxxx). A Sample\nentity must reference only one Platform and may be included in multiple\nSeries.\n:::\n\n::: {#series .section .level2}\n## [1.3]{.header-section-number} Series\n\nA Series record defines a set of related Samples considered to be part\nof a group, how the Samples are related, and if and how they are\nordered. A Series provides a focal point and description of the\nexperiment as a whole. Series records may also contain tables describing\nextracted data, summary conclusions, or analyses. Each Series record is\nassigned a unique and stable GEO accession number (GSExxx). Series\nrecords are available in a couple of formats which are handled by\nGEOquery independently. The smaller and new GSEMatrix files are quite\nfast to parse; a simple flag is used by GEOquery to choose to use\nGSEMatrix files (see below).\n:::\n\n::: {#datasets .section .level2}\n## [1.4]{.header-section-number} Datasets\n\nGEO DataSets (GDSxxx) are curated sets of GEO Sample data. A GDS record\nrepresents a collection of biologically and statistically comparable GEO\nSamples and forms the basis of GEO's suite of data display and analysis\ntools. Samples within a GDS refer to the same Platform, that is, they\nshare a common set of probe elements. Value measurements for each Sample\nwithin a GDS are assumed to be calculated in an equivalent manner, that\nis, considerations such as background processing and normalization are\nconsistent across the dataset. Information reflecting experimental\ndesign is provided through GDS subsets.\n:::\n:::\n\n::: {#getting-started-using-geoquery .section .level1}\n# [2]{.header-section-number} Getting Started using GEOquery\n\nGetting data from GEO is really quite easy. There is only one command\nthat is needed, `getGEO`. This one function interprets its input to\ndetermine how to get the data from GEO and then parse the data into\nuseful R data structures. Usage is quite simple. This loads the GEOquery\nlibrary.\n\n::: {#cb1 .sourceCode}\n``` {.sourceCode .r}\nlibrary(GEOquery)\n```\n:::\n\nNow, we are free to access any GEO accession. *Note that in the\nfollowing, I use a file packaged with the GEOquery package. In general,\nyou will use only the GEO accession, as noted in the code comments.*\n\n::: {#cb2 .sourceCode}\n``` {.sourceCode .r}\n# If you have network access, the more typical way to do this\n# would be to use this:\n# gds <- getGEO(\"GDS507\")\ngds <- getGEO(filename=system.file(\"extdata/GDS507.soft.gz\",package=\"GEOquery\"))\n```\n:::\n\nNow, `gds` contains the R data structure (of class `GDS`) that\nrepresents the GDS507 entry from GEO. You'll note that the filename used\nto store the download was output to the screen (but not saved anywhere)\nfor later use to a call to `getGEO(filename=...)`.\n\nWe can do the same with any other GEO accession, such as `GSM11805`, a\nGEO sample.\n\n::: {#cb3 .sourceCode}\n``` {.sourceCode .r}\n# If you have network access, the more typical way to do this\n# would be to use this:\n# gds <- getGEO(\"GSM11805\")\ngsm <- getGEO(filename=system.file(\"extdata/GSM11805.txt.gz\",package=\"GEOquery\"))\n```\n:::\n:::\n\n::: {#geoquery-data-structures .section .level1}\n# [3]{.header-section-number} GEOquery Data Structures\n\nThe GEOquery data structures really come in two forms. The first,\ncomprising `GDS`, `GPL`, and `GSM` all behave similarly and accessors\nhave similar effects on each. The fourth GEOquery data structure, `GSE`\nis a composite data type made up of a combination of `GSM` and `GPL`\nobjects. I will explain the first three together first.\n\n::: {#the-gds-gsm-and-gpl-classes .section .level2}\n## [3.1]{.header-section-number} The GDS, GSM, and GPL classes\n\nEach of these classes is comprised of a metadata header (taken nearly\nverbatim from the SOFT format header) and a GEODataTable. The\nGEODataTable has two simple parts, a Columns part which describes the\ncolumn headers on the Table part. There is also a `show` method for each\nclass. For example, using the gsm from above:\n\n::: {#cb4 .sourceCode}\n``` {.sourceCode .r}\n# Look at gsm metadata:\nhead(Meta(gsm))\n```\n:::\n\n    ## $channel_count\n    ## [1] \"1\"\n    ## \n    ## $comment\n    ## [1] \"Raw data provided as supplementary file\"\n    ## \n    ## $contact_address\n    ## [1] \"715 Albany Street, E613B\"\n    ## \n    ## $contact_city\n    ## [1] \"Boston\"\n    ## \n    ## $contact_country\n    ## [1] \"USA\"\n    ## \n    ## $contact_department\n    ## [1] \"Genetics and Genomics\"\n\n::: {#cb6 .sourceCode}\n``` {.sourceCode .r}\n# Look at data associated with the GSM:\n# but restrict to only first 5 rows, for brevity\nTable(gsm)[1:5,]\n```\n:::\n\n    ##           ID_REF  VALUE ABS_CALL\n    ## 1 AFFX-BioB-5_at  953.9        P\n    ## 2 AFFX-BioB-M_at 2982.8        P\n    ## 3 AFFX-BioB-3_at 1657.9        P\n    ## 4 AFFX-BioC-5_at 2652.7        P\n    ## 5 AFFX-BioC-3_at 2019.5        P\n\n::: {#cb8 .sourceCode}\n``` {.sourceCode .r}\n# Look at Column descriptions:\nColumns(gsm)\n```\n:::\n\n    ##     Column\n    ## 1         \n    ## 2    VALUE\n    ## 3 ABS_CALL\n    ##                                                                  Description\n    ## 1                                                                   ID_REF =\n    ## 2                         MAS 5.0 Statistical Algorithm (mean scaled to 500)\n    ## 3 MAS 5.0 Absent, Marginal, Present call  with Alpha1 = 0.05, Alpha2 = 0.065\n\nThe `GPL` class behaves exactly as the `GSM` class. However, the `GDS`\nclass has a bit more information associated with the `Columns` method:\n\n::: {#cb10 .sourceCode}\n``` {.sourceCode .r}\nColumns(gds)[,1:3]\n```\n:::\n\n    ##      sample disease.state individual\n    ## 1  GSM11815           RCC        035\n    ## 2  GSM11832           RCC        023\n    ## 3  GSM12069           RCC        001\n    ## 4  GSM12083           RCC        005\n    ## 5  GSM12101           RCC        011\n    ## 6  GSM12106           RCC        032\n    ## 7  GSM12274           RCC          2\n    ## 8  GSM12299           RCC          3\n    ## 9  GSM12412           RCC          4\n    ## 10 GSM11810        normal        035\n    ## 11 GSM11827        normal        023\n    ## 12 GSM12078        normal        001\n    ## 13 GSM12099        normal        005\n    ## 14 GSM12269        normal          1\n    ## 15 GSM12287        normal          2\n    ## 16 \n\n[Content truncated...]",
    "source": "vignette",
    "matches_above_threshold": [
      {
        "edam_id": "http://edamontology.org/data_1147",
        "edam_label": "GEO accession number",
        "confidence_score": 0.9,
        "reasoning": "The GEOquery package is designed to access and retrieve data from the NCBI Gene Expression Omnibus (GEO), which is a public repository for high-throughput experimental data, including microarray-based experiments. The package facilitates the extraction and conversion of GEO data into R data structures for further analysis. The most relevant EDAM ontology term for this functionality is \"GEO accession number,\" as it directly relates to the retrieval and handling of GEO data entries.",
        "validated": true
      },
      {
        "edam_id": "http://edamontology.org/operation_0224",
        "edam_label": "Query and retrieval",
        "confidence_score": 0.9,
        "reasoning": "The GEOquery package is primarily used for accessing and retrieving data from the NCBI Gene Expression Omnibus (GEO), which is a repository for high-throughput experimental data, including microarray and sequencing data. The package facilitates the extraction and conversion of GEO data into R data structures for further analysis. Given this functionality, the most relevant EDAM ontology term is \"Query and retrieval,\" as it encompasses the process of searching and retrieving data from a database, which aligns with the core purpose of the GEOquery package.",
        "validated": true
      },
      {
        "edam_id": "http://edamontology.org/operation_0314",
        "edam_label": "Gene expression profiling",
        "confidence_score": 0.9,
        "reasoning": "The GEOquery package is primarily used for accessing and handling data from the NCBI Gene Expression Omnibus (GEO), which includes high-throughput experimental data such as microarray data. The package facilitates the retrieval and conversion of GEO data into R data structures for further analysis, particularly focusing on gene expression data. Among the candidate terms, \"Gene expression profiling\" is the most relevant as it directly pertains to the measurement and analysis of gene expression levels, which is a core functionality of the GEOquery package.",
        "validated": true
      },
      {
        "edam_id": "http://edamontology.org/topic_3518",
        "edam_label": "Microarray experiment",
        "confidence_score": 0.9,
        "reasoning": "The GEOquery package is primarily focused on retrieving and managing data from the NCBI Gene Expression Omnibus (GEO), which includes high-throughput experimental data such as microarray-based experiments. The most relevant EDAM ontology term for this package is \"Microarray experiment,\" as it directly pertains to the type of data (microarray) that GEOquery is designed to handle, including the conditions, protocols, and sample data relationships.",
        "validated": true
      }
    ],
    "suggested_new_category": {
      "suggested_label": "GEO data retrieval and processing",
      "suggested_category": "operation",
      "justification": "The GEOquery package provides a specialized operation for accessing, retrieving, and processing data from the GEO database. While there are existing terms related to data retrieval and annotation, they do not specifically address the unique aspects of handling GEO data, which includes converting various GEO data types (such as GDS, GSM, and GSE) into R data structures. This operation is distinct from general data retrieval or annotation because it involves specific methods and data structures unique to GEO. Therefore, a new term is needed to accurately describe this operation within the EDAM ontology.",
      "similar_terms": [
        "Query and retrieval",
        "Annotation",
        "Indexing"
      ],
      "confidence_score": 0.85
    }
  },
  {
    "name": "miloR",
    "description": "# Extracted content from miloR.pdf\n\n## Package \u2018miloR\u2019\n\n#### July 21, 2025\n\n**Type Package**\n\n**Title Differential neighbourhood abundance testing on a graph**\n\n**Version 2.4.1**\n\n**Description Milo performs single-cell differential abundance testing. Cell states are modelled**\nas representative neighbourhoods on a nearest neighbour graph. Hypothesis testing is performed using either\na negative bionomial generalized linear model or negative binomial generalized linear mixed model.\n\n**License GPL-3 + file LICENSE**\n\n**Encoding UTF-8**\n\n**[URL https://marionilab.github.io/miloR](https://marionilab.github.io/miloR)**\n\n**[BugReports https://github.com/MarioniLab/miloR/issues](https://github.com/MarioniLab/miloR/issues)**\n\n**biocViews SingleCell, MultipleComparison, FunctionalGenomics, Software**\n\n**LinkingTo Rcpp, RcppArmadillo, RcppEigen, RcppML**\n\n**Depends R (>= 4.0.0), edgeR**\n\n**Imports BiocNeighbors, BiocGenerics, SingleCellExperiment, Matrix (>=**\n1.3-0), MatrixGenerics, S4Vectors, stats, stringr, methods,\nigraph, irlba, utils, cowplot, BiocParallel, BiocSingular,\nlimma, ggplot2, tibble, matrixStats, ggraph, gtools,\nSummarizedExperiment, patchwork, tidyr, dplyr, ggrepel,\nggbeeswarm, RColorBrewer, grDevices, Rcpp, pracma, numDeriv\n\n**Suggests testthat, mvtnorm, scater, scran, covr, knitr, rmarkdown,**\nuwot, scuttle, BiocStyle, MouseGastrulationData,\nMouseThymusAgeing, magick, RCurl, MASS, curl, scRNAseq,\ngraphics, sparseMatrixStats\n\n**RoxygenNote 7.3.2**\n\n**NeedsCompilation no**\n\n**Collate 'AllClasses.R' 'AllGenerics.R' 'buildFromAdjacency.R'**\n'buildGraph.R' 'calcNhoodExpression.R' 'calcNhoodDistance.R'\n'checkSeparation.R' 'countCells.R' 'findNhoodMarkers.R'\n'graphSpatialFDR.R' 'glmm.R' 'makeNhoods.R' 'milo.R'\n\n1\n\n\n-----\n\n2 _Contents_\n\n'miloR-package.R' 'methods.R' 'plotNhoods.R' 'sim_discrete.R'\n'sim_family.R' 'sim_nbglmm.R' 'sim_trajectory.R' 'testNhoods.R'\n'testDiffExp.R' 'utils.R' 'buildNhoodGraph.R'\n'annotateNhoods.R' 'groupNhoods.R' 'findNhoodGroupMarkers.R'\n'RcppExports.R' 'miloR.R'\n\n**VignetteBuilder knitr**\n\n**git_url https://git.bioconductor.org/packages/miloR**\n\n**git_branch RELEASE_3_21**\n\n**git_last_commit 296b8dd**\n\n**git_last_commit_date 2025-05-08**\n\n**Repository Bioconductor 3.21**\n\n**Date/Publication 2025-07-20**\n\n**[Author Mike Morgan [aut, cre] (ORCID: <https://orcid.org/0000-0003-0757-0711>),](https://orcid.org/0000-0003-0757-0711)**\nEmma Dann [aut, ctb]\n\n**Maintainer Mike Morgan <michael.morgan@abdn.ac.uk>**\n\n### Contents\n\nmiloR-package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\nannotateNhoods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\nbuildFromAdjacency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\nbuildGraph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\nbuildNhoodGraph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\ncalcNhoodDistance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8\ncalcNhoodExpression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\ncheckSeparation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\ncomputePvalue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\ncountCells . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\nfindNhoodGroupMarkers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\nfindNhoodMarkers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\nfitGeneticPLGlmm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\nfitGLMM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\nfitPLGlmm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\nglmmControl.defaults . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\ngraphSpatialFDR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\ngroupNhoods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\ninitialiseG . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\ninitializeFullZ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\nmakeNhoods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30\nmatrix.trace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\nMilo-class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\nMilo-methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34\nmiloR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\nplotDAbeeswarm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\nplotNhoodCounts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n\n\n-----\n\n_miloR-package_ 3\n\nplotNhoodExpressionDA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38\nplotNhoodGraph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\nplotNhoodGraphDA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41\nplotNhoodGroups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\nplotNhoodMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\nplotNhoodSizeHist . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44\nSatterthwaite_df . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45\nsim_discrete . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\nsim_family . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\nsim_nbglmm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\nsim_trajectory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48\ntestDiffExp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49\ntestNhoods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n\n**Index** **55**\n\nmiloR-package _The miloR package_\n\n**Description**\n\nThe miloR package provides modular functions to perform differential abundance testing on replicated single-cell experiments. For details please see the vignettes vignette(\"milo_demo\", package=\"miloR\")\nand vignette(\"milo_gastrulation\", package=\"miloR\").\n\n**Value**\n\nThe miloR package\n\n**Author(s)**\n\nMike Morgan & Emma Dann\n\nannotateNhoods _Add annotations from colData to DA testing results_\n\n**Description**\n\nThis function assigns a categorical label to neighbourhoods in the differential abundance results\ndata.frame (output of testNhoods), based on the most frequent label among cells in each neighbourhood. This can be useful to stratify DA testing results by cell types or samples. Also the\nfraction of cells carrying that label is stored.\n\n**Usage**\n\nannotateNhoods(x, da.res, coldata_col, subset.nhoods = NULL)\n\n\n-----\n\n4 _buildFromAdjacency_\n\n**Arguments**\n\nx A Milo object containing single-cell gene expression and neighbourhoods.\n\nda.res A data.frame containing DA results, as expected from running testNhoods.\n\ncoldata_col A character scalar determining which column of colData(x) stores the annotation to be added to the neighbourhoods\n\nsubset.nhoods A character, numeric or logical vector that will subset the annotation to the specific nhoods. If a character vector these should correspond to row names of\nnhoodCounts. If a logical vector then these should have the same length as\nnrow of nhoodCounts. If numeric, then these are assumed to correspond to indices of nhoodCounts - if the maximal index is greater than nrow(nhoodCounts(x))\nan error will be produced. This is necessary if testNhoods was run using\nsubset.nhoods=....\n\n**Details**\n\nFor each neighbourhood, this calculates the most frequent value of colData(x)[coldata_col]\namong cells in the neighbourhood and assigns that value as annotation for the neighbourhood,\nadding a column in the da.res data.frame. In addition, a coldata_col_fraction column will be\nadded, storing the fraction of cells carrying the assigned label. While in practice neighbourhoods\nare often homogeneous, one might choose to remove an annotation label when the fraction of cells\nwith the label is too low (e.g. below 0.6).\n\n**Value**\n\nA data.frame of model results (as da.res input) with two new columns: (1) coldata_col storing\nthe assigned label for each neighbourhood; (2) coldata_col_fraction storing the fraction of cells\nin the neighbourhood with the assigned label.\n\n**Author(s)**\n\nEmma Dann\n\n**Examples**\n\nNULL\n\nbuildFromAdjacency _Build a graph from an input adjacency matrix_\n\n**Description**\n\nConstruct a kNN-graph from an input adjacency matrix - either binary or distances between NNs.\n\n\n-----\n\n_buildGraph_ 5\n\n**Arguments**\n\nx An n X n matrix of single-cells, where values represent edges between cells;\n0 values are taken to mean no edge between cells. If the matrix is not binary,\nthen it is assumed the values are distances; 0 retain the same meaning. This\nbehaviour can be toggled using is.binary=TRUE.\n\nk (optional) Scalar value that represents the number of nearest neighbours in the\noriginal graph. This can also be inferred directly from the adjacency matrix x.\n\nis.binary Logical scalar indicating if the input matrix is binary or not.\n\n**Details**\n\nThis function will take a matrix as input and construct the kNN graph that it describes. If the matrix\nis not symmetric then the graph is assumed to be directed, whereas if the matrix is not binary, i.e.\nall 0\u2019s and 1\u2019s then the input values are taken to be distances between graph vertices; 0 values are\nassumed to represent a lack of edge between vertices.\n\n**Va\n\n[Content truncated...]",
    "source": "vignette",
    "matches_above_threshold": [
      {
        "edam_id": "http://edamontology.org/data_0951",
        "edam_label": "Statistical estimate score",
        "confidence_score": 0.8,
        "reasoning": "The miloR package is designed for differential abundance testing in single-cell experiments, focusing on cell states modeled as neighborhoods on a graph. This involves statistical analysis and hypothesis testing, which aligns with the concept of \"Statistical estimate score\" as it involves estimating statistical significance of observed data, particularly in the context of differential testing.",
        "validated": true
      },
      {
        "edam_id": "http://edamontology.org/data_3753",
        "edam_label": "Over-representation data",
        "confidence_score": 0.85,
        "reasoning": "The miloR package is designed for differential abundance testing in single-cell experiments, which involves statistical analysis of cell states modeled as neighborhoods on a graph. The package description emphasizes hypothesis testing using models like the negative binomial generalized linear model. Among the candidate terms, \"Over-representation data\" is the most relevant as it involves statistical metrics of over-/under-representation, which aligns with the differential abundance testing performed by miloR.",
        "validated": true
      },
      {
        "edam_id": "http://edamontology.org/operation_3223",
        "edam_label": "Differential gene expression profiling",
        "confidence_score": 0.8,
        "reasoning": "The miloR package is designed for differential abundance testing in single-cell experiments, focusing on modeling cell states as neighborhoods on a graph. This aligns closely with the concept of \"Differential gene expression profiling,\" which involves identifying genes with significantly different expression levels between sample groups. Although miloR operates at the level of cell neighborhoods rather than individual genes, the core functionality of testing for differential abundance is conceptually similar to differential expression analysis.",
        "validated": true
      },
      {
        "edam_id": "http://edamontology.org/topic_2229",
        "edam_label": "Cell biology",
        "confidence_score": 0.9,
        "reasoning": "The miloR package is designed for differential abundance testing in single-cell experiments, focusing on modeling cell states as neighborhoods on a graph and performing hypothesis testing. This aligns closely with the field of \"Cell biology,\" which involves the study of cells, including their functions and interactions. The package's emphasis on single-cell analysis and neighborhood modeling fits well within the scope of cell biology, as it deals with understanding cellular behavior and characteristics.",
        "validated": true
      }
    ],
    "suggested_new_category": {
      "suggested_label": "Differential neighborhood abundance testing",
      "suggested_category": "Operation",
      "justification": "The miloR package introduces a unique approach to analyzing single-cell data by modeling cell states as neighborhoods on a graph and performing differential abundance testing. This involves specific statistical operations that are not covered by existing EDAM terms. The current terms related to cell biology or general statistical analysis do not adequately describe the graph-based differential testing approach used in miloR. A new term would help in categorizing and identifying tools and methods that use similar graph-based statistical techniques in single-cell analysis.",
      "similar_terms": [
        "Differential expression analysis",
        "Graph-based analysis",
        "Single-cell analysis"
      ],
      "confidence_score": 0.85
    }
  }
]