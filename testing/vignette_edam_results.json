{
  "packages": [
    {
      "name": "miloR",
      "description": "# Extracted content from milo_demo.md\n\n::: {.container-fluid .main-container}\n::: row\n::: {.col-xs-12 .col-sm-4 .col-md-3}\n::: {#TOC .tocify}\n:::\n:::\n\n::: {.toc-content .col-xs-12 .col-sm-8 .col-md-9}\n::: {#header}\n# Differential abundance testing with Milo {#differential-abundance-testing-with-milo .title .toc-ignore}\n\nEmma Dann and Mike Morgan\n\n#### 11 May 2025 {#may-2025 .date}\n\n#### Package {#package .package}\n\nmiloR 2.4.1\n:::\n\n``` r\nlibrary(miloR)\nlibrary(SingleCellExperiment)\nlibrary(scater)\nlibrary(scran)\nlibrary(dplyr)\nlibrary(patchwork)\n```\n\n::: {#introduction .section .level1}\n# [1]{.header-section-number} Introduction\n\nMilo is a tool for analysis of complex single cell datasets generated\nfrom replicated multi-condition experiments, which detects changes in\ncomposition between conditions. While differential abundance (DA) is\ncommonly quantified in discrete cell clusters, Milo uses partially\noverlapping neighbourhoods of cells on a KNN graph. Starting from a\ngraph that faithfully recapitulates the biology of the cell population,\nMilo analysis consists of 3 steps:\n\n1.  Sampling of representative neighbourhoods\n2.  Testing for differential abundance of conditions in all\n    neighbourhoods\n3.  Accounting for multiple hypothesis testing using a weighted FDR\n    procedure that accounts for the overlap of neighbourhoods\n\nIn this vignette we will elaborate on how these steps are implemented in\nthe `miloR` package.\n:::\n\n::: {#load-data .section .level1}\n# [2]{.header-section-number} Load data\n\nFor this demo we will use a synthetic dataset simulating a developmental\ntrajectory, generated using\n[dyntoy](https://github.com/dynverse/dyntoy).\n\n``` r\ndata(\"sim_trajectory\", package = \"miloR\")\n\n## Extract SingleCellExperiment object\ntraj_sce <- sim_trajectory[['SCE']]\n\n## Extract sample metadata to use for testing\ntraj_meta <- sim_trajectory[[\"meta\"]]\n\n## Add metadata to colData slot\ncolData(traj_sce) <- DataFrame(traj_meta)\ncolnames(traj_sce) <- colData(traj_sce)$cell_id\n\nredim <- reducedDim(traj_sce, \"PCA\")\ndimnames(redim) <- list(colnames(traj_sce), paste0(\"PC\", c(1:50)))\nreducedDim(traj_sce, \"PCA\") <- redim \n```\n:::\n\n::: {#pre-processing .section .level1}\n# [3]{.header-section-number} Pre-processing\n\nFor DA analysis we need to construct an undirected KNN graph of\nsingle-cells. Standard single-cell analysis pipelines usually do this\nfrom distances in PCA. We normalize and calculate principal components\nusing `scater`. I also run UMAP for visualization purposes.\n\n``` r\nlogcounts(traj_sce) <- log(counts(traj_sce) + 1)\ntraj_sce <- runPCA(traj_sce, ncomponents=30)\ntraj_sce <- runUMAP(traj_sce)\n\nplotUMAP(traj_sce)\n```\n\n![](data:image/png;base64,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\n\n[Content truncated...]",
      "source": "vignette",
      "edam_match": {
        "edam_id": "http://edamontology.org/data_3932",
        "edam_label": "Q-value",
        "confidence_score": 0.9,
        "reasoning": "The miloR package is designed for differential abundance testing in single-cell datasets, which involves analyzing changes in cell composition across conditions. This process includes sampling representative neighborhoods, testing for differential abundance, and accounting for multiple hypothesis testing using a weighted FDR procedure. The candidate term \"Q-value\" is relevant here as it is a score derived from the P-value to ensure correction for multiple tests, which aligns with the package's functionality of accounting for multiple hypothesis testing.",
        "validated": true
      }
    },
    {
      "name": "xcms",
      "description": "# Extracted content from xcms.md\n\n::: {.container-fluid .main-container}\n::: row\n::: {.col-xs-12 .col-sm-4 .col-md-3}\n::: {#TOC .tocify}\n:::\n:::\n\n::: {.toc-content .col-xs-12 .col-sm-8 .col-md-9}\n::: {#header}\n# LC-MS data preprocessing and analysis with xcms {#lc-ms-data-preprocessing-and-analysis-with-xcms .title .toc-ignore}\n\n#### 25 June 2025 {#june-2025 .date}\n\n#### Package {#package .package}\n\nxcms 4.6.3\n:::\n\n**Package**: *[xcms](https://bioconductor.org/packages/3.21/xcms)*\\\n**Authors**: Johannes Rainer\\\n**Modified**: 2025-04-15 14:33:14.734681\\\n**Compiled**: Wed Jun 25 19:48:31 2025\n\n::: {#introduction .section .level1}\n# [1]{.header-section-number} Introduction\n\nThe *[xcms](https://bioconductor.org/packages/3.21/xcms)* package\nprovides the functionality to perform the preprocessing of LC-MS, GC-MS\nor LC-MS/MS data in which raw signals from mzML, mzXML or CDF files are\nprocessed into *feature* abundances. This preprocessing includes\nchromatographic peak detection, sample alignment and correspondence\nanalysis.\n\nThe first version of the package was already published in 2006\n[\\[[1](#ref-Smith:2006ic){role=\"doc-biblioref\"}\\]]{.citation} and has\nsince been updated and modernized in several rounds to better integrate\nit with other R-based packages for the analysis of untargeted\nmetabolomics data. This includes version 3 of *xcms* that used the\n*[MSnbase](https://bioconductor.org/packages/3.21/MSnbase)* package for\nMS data representation\n[\\[[2](#ref-gattoMSnbaseEfficientElegant2020a){role=\"doc-biblioref\"}\\]]{.citation}.\nThe most recent update (*xcms* version 4) enables in addition\npreprocessing of MS data represented by the modern\n*[MsExperiment](https://bioconductor.org/packages/3.21/MsExperiment)*\nand *[Spectra](https://bioconductor.org/packages/3.21/Spectra)* packages\nwhich provides an even better integration with the\n[RforMassSpectrometry](https://rformassspectrometry.org) R package\necosystem simplifying e.g.\u00a0also compound annotation\n[\\[[3](#ref-rainer_modular_2022){role=\"doc-biblioref\"}\\]]{.citation}.\n\nThis document describes data import, exploration and preprocessing of a\nsimple test LC-MS data set with the *xcms* package version \\>= 4. The\nsame functions can be applied to the older *MSnbase*-based workflows\n(xcms version 3). Additional documents and tutorials covering also other\ntopics of untargeted metabolomics analysis are listed at the end of this\ndocument. There is also a [xcms\ntutorial](https://jorainer.github.io/xcmsTutorials) available with more\nexamples and details. To get a complete overview of LCMS-MS analysis, an\nend-to-end workflow [Metabonaut\nwebsite](https://rformassspectrometry.github.io/metabonaut/), which\nintegrate the *xcms* preprocessing steps with the downstream analysis,\nis available.\n:::\n\n::: {#preprocessing-of-lc-ms-data .section .level1}\n# [2]{.header-section-number} Preprocessing of LC-MS data\n\n::: {#data-import .section .level2}\n## [2.1]{.header-section-number} Data import\n\n*xcms* supports analysis of any LC-MS(/MS) data that can be imported\nwith the *[Spectra](https://bioconductor.org/packages/3.21/Spectra)*\npackage. Such data will typically be provided in (AIA/ANDI) NetCDF,\nmzXML and mzML format but can, through dedicated extensions to the\n*Spectra* package, also be imported from other sources, e.g.\u00a0also\ndirectly from raw data files in manufacturer's formats.\n\nFor demonstration purpose we will analyze in this document a small\nsubset of the data from\n[\\[[4](#ref-Saghatelian04){role=\"doc-biblioref\"}\\]]{.citation} in which\nthe metabolic consequences of the knock-out of the fatty acid amide\nhydrolase (FAAH) gene in mice was investigated. The raw data files (in\nNetCDF format) are provided through the\n*[faahKO](https://bioconductor.org/packages/3.21/faahKO)* data package.\nThe data set consists of samples from the spinal cords of 6 knock-out\nand 6 wild-type mice. Each file contains data in centroid mode acquired\nin positive ion polarity from 200-600 m/z and 2500-4500 seconds. To\nspeed-up processing of this vignette we will restrict the analysis to\nonly 8 files.\n\nBelow we load all required packages, locate the raw CDF files within the\n*faahKO* package and build a *phenodata* `data.frame` describing the\nexperimental setup. Generally, such data frames should contain all\nrelevant experimental variables and sample descriptions (including also\nthe names of the raw data files) and will be imported into R using\neither the `read.table()` function (if the file is in *csv* or tabulator\ndelimited text file format) or also using functions from the *readxl* R\npackage if it is in Excel file format.\n\n``` r\nlibrary(xcms)\nlibrary(faahKO)\nlibrary(RColorBrewer)\nlibrary(pander)\nlibrary(pheatmap)\nlibrary(MsExperiment)\n\n## Get the full path to the CDF files\ncdfs <- dir(system.file(\"cdf\", package = \"faahKO\"), full.names = TRUE,\n            recursive = TRUE)[c(1, 2, 5, 6, 7, 8, 11, 12)]\n## Create a phenodata data.frame\npd <- data.frame(sample_name = sub(basename(cdfs), pattern = \".CDF\",\n                                   replacement = \"\", fixed = TRUE),\n                 sample_group = c(rep(\"KO\", 4), rep(\"WT\", 4)),\n                 stringsAsFactors = FALSE)\n```\n\nWe next load our data using the `readMsExperiment` function from the\n*[MsExperiment](https://bioconductor.org/packages/3.21/MsExperiment)*\npackage.\n\n``` r\nfaahko <- readMsExperiment(spectraFiles = cdfs, sampleData = pd)\nfaahko\n```\n\n    ## Object of class MsExperiment \n    ##  Spectra: MS1 (10224) \n    ##  Experiment data: 8 sample(s)\n    ##  Sample data links:\n    ##   - spectra: 8 sample(s) to 10224 element(s).\n\nThe MS spectra data from our experiment is now available as a `Spectra`\nobject within `faahko`. Note that this `MsExperiment` container could in\naddition to spectra data also contain other types of data or also\nreferences to other files. See the vignette from the\n*[MsExperiment](https://bioconductor.org/packages/3.21/MsExperiment)*\nfor more details. Also, when loading data from mzML, mzXML or CDF files,\nby default only general spectra data is loaded into memory while the\nactual *peaks data*, i.e.\u00a0the m/z and intensity values are only\nretrieved on-the-fly from the raw files when needed (this is similar to\nthe *MSnbase* *on-disk* mode described in\n[\\[[2](#ref-gattoMSnbaseEfficientElegant2020a){role=\"doc-biblioref\"}\\]]{.citation}).\nThis guarantees a low memory footprint hence allowing to analyze also\nlarge experiments without the need of high performance computing\nenvironments. Note that also different alternative *backends* (and hence\ndata representations) could be used for the `Spectra` object within\n`faahko` with eventually even lower memory footprint, or higher\nperformance. See the package vignette from the\n*[Spectra](https://bioconductor.org/packages/3.21/Spectra)* package or\nthe [SpectraTutorials](https://jorainer.github.io/SpectraTutorials)\ntutorial for more details on `Spectra` backends and how to change\nbetween them.\n:::\n\n::: {#initial-data-inspection .section .level2}\n## [2.2]{.header-section-number} Initial data inspection\n\nThe `MsExperiment` object is a simple and flexible container for MS\nexperiments. The *raw* MS data is stored as a `Spectra` object that can\nbe accessed through the `spectra()` function.\n\n``` r\nspectra(faahko)\n```\n\n    ## MSn data (Spectra) with 10224 spectra in a MsBackendMzR backend:\n    ##         msLevel     rtime scanIndex\n    ##       <integer> <numeric> <integer>\n    ## 1             1   2501.38         1\n    ## 2             1   2502.94         2\n    ## 3             1   2504.51         3\n    ## 4             1   2506.07         4\n    ## 5             1   2507.64         5\n    ## ...         ...       ...       ...\n    ## 10220         1   4493.56      1274\n    ## 10221         1   4495.13      1275\n    ## 10222         1   4496.69      1276\n    ## 10223         1   4498.26      1277\n    ## 10224         1   4499.82      1278\n    ##  ... 33 more variables/columns.\n    ## \n    ## file(s):\n    ## ko15.CDF\n    ## ko16.CDF\n    ## ko21.CDF\n    ##  ... 5 more files\n\nAll spectra are organized *sequentially* (i.e., not by file) but the\n`fromFile()` function can be used to get for each spectrum the\ninformation to which of the data files it belongs. Below we simply count\nthe number of spectra per file.\n\n``` r\ntable(fromFile(faahko))\n```\n\n    ## \n    ##    1    2    3    4    5    6    7    8 \n    ## 1278 1278 1278 1278 1278 1278 1278 1278\n\nInformation on samples can be retrieved through the `sampleData()`\nfunction.\n\n``` r\nsampleData(faahko)\n```\n\n    ## DataFrame with 8 rows and 3 columns\n    ##          sample_name sample_group spectraOrigin\n    ##          <character>  <character>   <character>\n    ## ko15.CDF        ko15           KO /home/bioc...\n    ## ko16.CDF        ko16           KO /home/bioc...\n    ## ko21.CDF        ko21           KO /home/bioc...\n    ## ko22.CDF        ko22           KO /home/bioc...\n    ## wt15.CDF        wt15           WT /home/bioc...\n    ## wt16.CDF        wt16           WT /home/bioc...\n    ## wt21.CDF        wt21           WT /home/bioc...\n    ## wt22.CDF        wt22           WT /home/bioc...\n\nEach row in this `DataFrame` represents one sample (input file). Using\n`[` it is possible to subset a `MsExperiment` object **by sample**.\nBelow we subset the `faahko` to the 3rd sample (file) and access its\nspectra and sample data.\n\n``` r\nfaahko_3 <- faahko[3]\nspectra(faahko_3)\n```\n\n    ## MSn data (Spectra) with 1278 spectra in a MsBackendMzR backend:\n    ##        msLevel     rtime scanIndex\n    ##      <integer> <numeric> <integer>\n    ## 1            1   2501.38         1\n    ## 2            1   2502.94         2\n    ## 3            1   2504.51         3\n    ## 4            1   2506.07         4\n    ## 5            1   2507.64         5\n    ## ...        ...       ...       ...\n    ## 1274         1   4493.56      1274\n    ## 1275         1   4495.13      1275\n    ## 1276         1   4496.69      1276\n    ## 1277         1   4498.26      1277\n    ## 1278         1   4499.82      1278\n    ##  ... 33 more variables/columns.\n    ## \n    ## file(s):\n    ## ko21.CDF\n\n``` r\nsampleData(faahko_3)\n```\n\n    ## DataFrame with 1 row and 3 columns\n    ##          sample_name sample_group spectraOrigin\n    ##          <character>  <character>   <character>\n    ## ko21.CDF        ko21           KO /home/bioc...\n\nAs a first evaluation of the data we below plot the base peak\nchromatogram (BPC) for each file in our experiment. We use the\n`chromatogram()` method and set the `aggregationFun` to `\"max\"` to\nreturn for each spectrum the maximal intensity and hence create the BPC\nfrom the raw data. To create a total ion chromatogram we could set\n`aggregationFun` to `\"sum\"`.\n\n``` r\n## Get the base peak chromatograms. This reads data from the files.\nbpis <- chromatogram(faahko, aggregationFun = \"max\")\n## Define colors for the two groups\ngroup_colors <- paste0(brewer.pal(3, \"Set1\")[1:2], \"60\")\nnames(group_colors) <- c(\"KO\", \"WT\")\n\n## Plot all chromatograms.\nplot(bpis, col = group_colors[sampleData(faahko)$sample_group])\n```\n\n::: {.figure style=\"text-align: center\"}\n[]{#fig:data-inspection-bpc style=\"display:block;\"} ![Base peak\nchromatogram.](data:image/png;base64,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\n\n[Content truncated...]",
      "source": "vignette",
      "edam_match": {
        "edam_id": "http://edamontology.org/operation_3933",
        "edam_label": "Demultiplexing",
        "confidence_score": 0.4,
        "reasoning": "The xcms package is primarily used for preprocessing and analyzing LC-MS data, which involves processing raw signals into feature abundances, including chromatographic peak detection, sample alignment, and correspondence analysis. None of the candidate terms directly match the specific operations or data formats used in LC-MS data analysis. However, the closest match is \"Demultiplexing\" (http://edamontology.org/operation_3933), which involves assigning sequence reads to separate groups based on their index tag. This is somewhat related to the sample alignment and correspondence analysis aspects of xcms, where data from different samples are processed and aligned. Although not a perfect match, it is the most relevant among the given options. | NEW DESIGNATION SUGGESTED: Mass spectrometry data preprocessing (operation)",
        "validated": true
      }
    },
    {
      "name": "limma",
      "description": "# Extracted content from intro.md\n\n::: {.container-fluid .main-container}\n::: {#header}\n# A brief introduction to limma {#a-brief-introduction-to-limma .title .toc-ignore}\n\n#### 23 October 2004 (last revised 11 June 2023) {#october-2004-last-revised-11-june-2023 .date}\n:::\n\n::: {#what-is-it .section .level1}\n# What is it?\n\nLimma is an R package for the analysis of gene expression data,\nespecially the use of linear models for analysing designed experiments\nand the assessment of differential expression. Limma provides the\nability to analyse comparisons between many RNA targets simultaneously\nin arbitrary complicated designed experiments. Empirical Bayesian\nmethods are used to provide stable results even when the number of\narrays is small. The normalization and background correction functions\nare provided for microarrays and similar technologies. The linear model\nand differential expression functions apply to a wide variety of gene\nexpression technologies including microarrays (single-channel or\ntwo-color), quantitative PCR, RNA-seq or proteomics.\n:::\n\n::: {#how-to-get-help .section .level1}\n# How to get help\n\nThe edgeR User's Guide is available by\n\n``` r\n> library(limma)\n> limmaRUsersGuide()\n```\n\nor alternatively from the [limma landing\npage](https://bioconductor.org/packages/limma).\n\nDocumentation for specific functions is available through the usual R\nhelp system, e.g., `?lmFit`. Further questions about the package should\nbe directed to the [Bioconductor support\nsite](https://support.bioconductor.org).\n:::\n\n::: {#further-reading .section .level1}\n# Further reading\n\nRitchie ME, Phipson B, Wu D, Hu Y, Law CW, Shi W, Smyth GK (2015). limma\npowers differential expression analyses for RNA-sequencing and\nmicroarray studies. *Nucleic Acids Research* 43, e47.\n[doi:10.1093/nar/gkv007](https://doi.org/10.1093/nar/gkv007)\n\nPhipson B, Lee S, Majewski IJ, Alexander WS, and Smyth GK (2016). Robust\nhyperparameter estimation protects against hypervariable genes and\nimproves power to detect differential expression. *Annals of Applied\nStatistics* 10, 946-963. [doi:10.1214/16-AOAS920](10.1214/16-AOAS920)\n\nLaw CW, Chen Y, Shi W, Smyth GK (2014). Voom: precision weights unlock\nlinear model analysis tools for RNA-seq read counts. Genome Biology 15,\nR29.\n[doi:10.1186/gb-2014-15-2-r29](https://doi.org/10.1186/gb-2014-15-2-r29).\nSee also the Preprint Version at\n<https://gksmyth.github.io/pubs/VoomPreprint.pdf> incorporating some\nnotational corrections.\n\nLaw CW, Alhamdoosh M, Su S, Dong X, Tian L, Smyth GK, Ritchie ME (2016).\nRNA-seq analysis is easy as 1-2-3 with limma, Glimma and edgeR.\n*F1000Research* 5, 1408.\n[doi:10.12688/f1000research.9005.3](https://doi.org/10.12688/f1000research.9005.3)\n\nLaw CW, Zeglinski K, Dong X, Alhamdoosh M, Smyth GK, Ritchie ME (2020).\nA guide to creating design matrices for gene expression experiments.\n*F1000Research* 9, 1444.\n[doi:10.12688/f1000research.27893.1](https://doi.org/10.12688/f1000research.27893.1)\n:::\n:::\n",
      "source": "vignette",
      "edam_match": {
        "edam_id": "http://edamontology.org/operation_3223",
        "edam_label": "Differential gene expression profiling",
        "confidence_score": 0.95,
        "reasoning": "The limma package is primarily used for the analysis of gene expression data, particularly focusing on differential expression analysis using linear models. It is designed to handle data from various gene expression technologies, including microarrays and RNA-seq. The candidate term \"Differential gene expression profiling\" directly aligns with the core functionality of limma, which is to identify genes with significantly different expression levels between sample groups. This makes it the most relevant EDAM ontology term for the package.",
        "validated": true
      }
    },
    {
      "name": "DESeq2",
      "description": "# Extracted content from DESeq2.md\n\n::: {.container-fluid .main-container}\n::: {#header}\n# Analyzing RNA-seq data with DESeq2 {#analyzing-rna-seq-data-with-deseq2 .title .toc-ignore}\n\n#### Michael I. Love, Simon Anders, and Wolfgang Huber {#michael-i.-love-simon-anders-and-wolfgang-huber .author}\n\n#### 05/11/2025 {#section .date}\n\n::: abstract\nAbstract\n\nA basic task in the analysis of count data from RNA-seq is the detection\nof differentially expressed genes. The count data are presented as a\ntable which reports, for each sample, the number of sequence fragments\nthat have been assigned to each gene. Analogous data also arise for\nother assay types, including comparative ChIP-Seq, HiC, shRNA screening,\nand mass spectrometry. An important analysis question is the\nquantification and statistical inference of systematic changes between\nconditions, as compared to within-condition variability. The package\nDESeq2 provides methods to test for differential expression by use of\nnegative binomial generalized linear models; the estimates of dispersion\nand logarithmic fold changes incorporate data-driven prior\ndistributions. This vignette explains the use of the package and\ndemonstrates typical workflows. [An RNA-seq\nworkflow](http://www.bioconductor.org/help/workflows/rnaseqGene/) on the\nBioconductor website covers similar material to this vignette but at a\nslower pace, including the generation of count matrices from FASTQ\nfiles. DESeq2 package version: 1.48.1\n:::\n:::\n\n::: {#TOC}\n-   [Standard workflow](#standard-workflow)\n    -   [Quick start](#quick-start)\n    -   [How to get help for DESeq2](#how-to-get-help-for-deseq2)\n    -   [Acknowledgments](#acknowledgments)\n    -   [Funding](#funding)\n    -   [Input data](#input-data)\n        -   [Why un-normalized counts?](#why-un-normalized-counts)\n        -   [The DESeqDataSet](#the-deseqdataset)\n        -   [Transcript abundance files and *tximport* /\n            *tximeta*](#transcript-abundance-files-and-tximport-tximeta)\n        -   [Tximeta for import with automatic\n            metadata](#tximeta-for-import-with-automatic-metadata)\n        -   [Count matrix input](#count-matrix-input)\n        -   [*htseq-count* input](#htseq-count-input)\n        -   [*SummarizedExperiment* input](#summarizedexperiment-input)\n        -   [Pre-filtering](#pre-filtering)\n        -   [Note on factor levels](#note-on-factor-levels)\n        -   [Collapsing technical\n            replicates](#collapsing-technical-replicates)\n        -   [About the pasilla dataset](#about-the-pasilla-dataset)\n    -   [Differential expression\n        analysis](#differential-expression-analysis)\n        -   [Log fold change shrinkage for visualization and\n            ranking](#log-fold-change-shrinkage-for-visualization-and-ranking)\n        -   [Speed-up and parallelization\n            thoughts](#speed-up-and-parallelization-thoughts)\n        -   [p-values and adjusted\n            p-values](#p-values-and-adjusted-p-values)\n        -   [Independent hypothesis\n            weighting](#independent-hypothesis-weighting)\n    -   [Exploring and exporting\n        results](#exploring-and-exporting-results)\n        -   [MA-plot](#ma-plot)\n        -   [Alternative shrinkage\n            estimators](#alternative-shrinkage-estimators)\n        -   [Plot counts](#plot-counts)\n        -   [More information on results\n            columns](#more-information-on-results-columns)\n        -   [Rich visualization and reporting of\n            results](#rich-visualization-and-reporting-of-results)\n        -   [Exporting results to CSV\n            files](#exporting-results-to-csv-files)\n    -   [Multi-factor designs](#multi-factor-designs)\n-   [Data transformations and\n    visualization](#data-transformations-and-visualization)\n    -   [Count data transformations](#count-data-transformations)\n        -   [Blind dispersion estimation](#blind-dispersion-estimation)\n        -   [Extracting transformed\n            values](#extracting-transformed-values)\n        -   [Variance stabilizing\n            transformation](#variance-stabilizing-transformation)\n        -   [Regularized log\n            transformation](#regularized-log-transformation)\n        -   [Effects of transformations on the\n            variance](#effects-of-transformations-on-the-variance)\n    -   [Data quality assessment by sample clustering and\n        visualization](#data-quality-assessment-by-sample-clustering-and-visualization)\n        -   [Heatmap of the count matrix](#heatmap-of-the-count-matrix)\n        -   [Heatmap of the sample-to-sample\n            distances](#heatmap-of-the-sample-to-sample-distances)\n        -   [Principal component plot of the\n            samples](#principal-component-plot-of-the-samples)\n-   [Variations to the standard\n    workflow](#variations-to-the-standard-workflow)\n    -   [Wald test individual steps](#wald-test-individual-steps)\n    -   [Control features for estimating size\n        factors](#control-features-for-estimating-size-factors)\n    -   [Contrasts](#contrasts)\n    -   [Interactions](#interactions)\n    -   [Time-series experiments](#time-series-experiments)\n    -   [Likelihood ratio test](#likelihood-ratio-test)\n    -   [Extended section on shrinkage\n        estimators](#extended-section-on-shrinkage-estimators)\n    -   [Recommendations for single-cell\n        analysis](#recommendations-for-single-cell-analysis)\n    -   [Approach to count outliers](#approach-to-count-outliers)\n    -   [Dispersion plot and fitting\n        alternatives](#dispersion-plot-and-fitting-alternatives)\n        -   [Local or mean dispersion\n            fit](#local-or-mean-dispersion-fit)\n        -   [Supply a custom dispersion\n            fit](#supply-a-custom-dispersion-fit)\n    -   [Independent filtering of\n        results](#independent-filtering-of-results)\n    -   [Tests of log2 fold change above or below a\n        threshold](#tests-of-log2-fold-change-above-or-below-a-threshold)\n    -   [Access to all calculated\n        values](#access-to-all-calculated-values)\n    -   [Sample-/gene-dependent normalization\n        factors](#sample-gene-dependent-normalization-factors)\n    -   [\"Model matrix not full rank\"](#model-matrix-not-full-rank)\n        -   [Linear combinations](#linear-combinations)\n        -   [Group-specific condition effects, individuals nested within\n            groups](#group-specific-condition-effects-individuals-nested-within-groups)\n        -   [Levels without samples](#levels-without-samples)\n-   [Theory behind DESeq2](#theory-behind-deseq2)\n    -   [The DESeq2 model](#the-deseq2-model)\n    -   [Changes compared to DESeq](#changes-compared-to-deseq)\n    -   [Methods changes since the 2014 DESeq2\n        paper](#methods-changes-since-the-2014-deseq2-paper)\n    -   [Count outlier detection](#count-outlier-detection)\n    -   [Contrasts](#contrasts-1)\n    -   [Expanded model matrices](#expanded-model-matrices)\n    -   [Independent filtering and multiple\n        testing](#independent-filtering-and-multiple-testing)\n        -   [Filtering criteria](#filtering-criteria)\n        -   [Why does it work?](#why-does-it-work)\n-   [Frequently asked questions](#frequently-asked-questions)\n    -   [How can I get support for\n        DESeq2?](#how-can-i-get-support-for-deseq2)\n    -   [Why are some *p* values set to\n        NA?](#why-are-some-p-values-set-to-na)\n    -   [How can I get unfiltered DESeq2\n        results?](#how-can-i-get-unfiltered-deseq2-results)\n    -   [How do I use VST or rlog data for differential\n        testing?](#how-do-i-use-vst-or-rlog-data-for-differential-testing)\n    -   [Why after VST are there still batches in the PCA\n        plot?](#why-after-vst-are-there-still-batches-in-the-pca-plot)\n    -   [Do normalized counts correct for variables in the\n        design?](#do-normalized-counts-correct-for-variables-in-the-design)\n    -   [Can I use DESeq2 to analyze paired\n        samples?](#can-i-use-deseq2-to-analyze-paired-samples)\n    -   [If I have multiple groups, should I run all together or split\n        into pairs of\n        groups?](#if-i-have-multiple-groups-should-i-run-all-together-or-split-into-pairs-of-groups)\n    -   [Can I run DESeq2 to contrast the levels of many\n        groups?](#can-i-run-deseq2-to-contrast-the-levels-of-many-groups)\n    -   [Can I use DESeq2 to analyze a dataset without\n        replicates?](#can-i-use-deseq2-to-analyze-a-dataset-without-replicates)\n    -   [How can I include a continuous covariate in the design\n        formula?](#how-can-i-include-a-continuous-covariate-in-the-design-formula)\n    -   [I ran a likelihood ratio test, but results() only gives me one\n        comparison.](#i-ran-a-likelihood-ratio-test-but-results-only-gives-me-one-comparison.)\n    -   [What are the exact steps performed by\n        DESeq()?](#what-are-the-exact-steps-performed-by-deseq)\n    -   [Is there an official Galaxy tool for\n        DESeq2?](#is-there-an-official-galaxy-tool-for-deseq2)\n    -   [I want to benchmark DESeq2 comparing to other DE\n        tools.](#i-want-to-benchmark-deseq2-comparing-to-other-de-tools.)\n    -   [I have trouble installing DESeq2 on\n        Ubuntu/Linux...](#i-have-trouble-installing-deseq2-on-ubuntulinux)\n-   [Session info](#session-info)\n-   [References](#references)\n:::\n\n::: {#standard-workflow .section .level1}\n# Standard workflow\n\n**Note:** if you use DESeq2 in published research, please cite:\n\n> Love, M.I., Huber, W., Anders, S. (2014) Moderated estimation of fold\n> change and dispersion for RNA-seq data with DESeq2. *Genome Biology*,\n> **15**:550.\n> [10.1186/s13059-014-0550-8](http://dx.doi.org/10.1186/s13059-014-0550-8)\n\nOther Bioconductor packages with similar aims are\n[edgeR](http://bioconductor.org/packages/edgeR),\n[limma](http://bioconductor.org/packages/limma),\n[DSS](http://bioconductor.org/packages/DSS),\n[EBSeq](http://bioconductor.org/packages/EBSeq), and\n[baySeq](http://bioconductor.org/packages/baySeq).\n\n::: {#quick-start .section .level2}\n## Quick start\n\nHere we show the most basic steps for a differential expression\nanalysis. There are a variety of steps upstream of DESeq2 that result in\nthe generation of counts or estimated counts for each sample, which we\nwill discuss in the sections below. This code chunk assumes that you\nhave a count matrix called `cts` and a table of sample information\ncalled `coldata`. The `design` indicates how to model the samples, here,\nthat we want to measure the effect of the condition, controlling for\nbatch differences. The two factor variables `batch` and `condition`\nshould be columns of `coldata`.\n\n::: {#cb1 .sourceCode}\n``` {.sourceCode .r}\ndds <- DESeqDataSetFromMatrix(countData = cts,\n                              colData = coldata,\n                              design= ~ batch + condition)\ndds <- DESeq(dds)\nresultsNames(dds) # lists the coefficients\nres <- results(dds, name=\"condition_trt_vs_untrt\")\n# or to shrink log fold changes association with condition:\nres <- lfcShrink(dds, coef=\"condition_trt_vs_untrt\", type=\"apeglm\")\n```\n:::\n\nThe following starting functions will be explained below:\n\n-   If you have performed transcript quantification (with *Salmon*,\n    *kallisto*, *RSEM*, etc.) you could import the data with *tximport*,\n    which produces a list, and then you can use\n    `DESeqDataSetFromTximport()`.\n-   If you imported quantification data with *tximeta*, which produces a\n    *SummarizedExperiment* with additional metadata, you can then use\n    `DESeqDataSet()`.\n-   If you have *htseq-count* files, you can use\n    `DESeqDataSetFromHTSeq()`.\n:::\n\n::: {#how-to-get-help-for-deseq2 .section .level2}\n## How to get help for DESeq2\n\nAny and all DESeq2 questions should be posted to the **Bioconductor\nsupport site**, which serves as a searchable knowledge base of questions\nand answers:\n\n<https://support.bioconductor.org>\n\nPosting a question and tagging with \"DESeq2\" will automatically send an\nalert to the package authors to respond on the support site. See the\nfirst question in the list of [Frequently Asked Questions](#FAQ) (FAQ)\nfor information about how to construct an informative post.\n\nYou should **not** email your question to the package authors, as we\nwill just reply that the question should be posted to the **Bioconductor\nsupport site**.\n:::\n\n::: {#acknowledgments .section .level2}\n## Acknowledgments\n\nConstantin Ahlmann-Eltze has contributed core code for increasing the\ncomputational performance of *DESeq2* and building an interface to his\n*glmGamPoi* package.\n\nWe have benefited in the development of *DESeq2* from the help and\nfeedback of many individuals, including but not limited to:\n\nThe Bionconductor Core Team, Alejandro Reyes, Andrzej Oles, Aleksandra\nPekowska, Felix Klein, Nikolaos Ignatiadis (IHW), Anqi Zhu (apeglm),\nJoseph Ibrahim (apeglm), Vince Carey, Owen Solberg, Ruping Sun, Devon\nRyan, Steve Lianoglou, Jessica Larson, Christina Chaivorapol, Pan Du,\nRichard Bourgon, Willem Talloen, Elin Videvall, Hanneke van Deutekom,\nTodd Burwell, Jesse Rowley, Igor Dolgalev, Stephen Turner, Ryan C\nThompson, Tyr Wiesner-Hanks, Konrad Rudolph, David Robinson, Mingxiang\nTeng, Mathias Lesche, Sonali Arora, Jordan Ramilowski, Ian Dworkin,\nBjorn Gruning, Ryan McMinds, Paul Gordon, Leonardo Collado Torres,\nEnrico Ferrero, Peter Langfelder, Gavin Kelly, Rob Patro, Charlotte\nSoneson, Koen Van den Berge, Fanny Perraudeau, Davide Risso, Stephan\nEngelbrecht, Nicolas Alcala, Jeremy Simon, Travis Ptacek, Rory Kirchner,\nR. Butler, Ben Keith, Dan Liang, Nil Ayg\u00fcn, Rory Nolan, Michael\nSchubert, Hugo Tavares, Eric Davis, Wancen Mu, Zhang Cheng, Frederik\nZiebell, Luca Menestrina, Hendrik Weisse, I-Hsuan Lin, Rasmus\nHenningsson, Alexey Sergushichev.\n:::\n\n::: {#funding .section .level2}\n## Funding\n\nDESeq2 and its developers have been partially supported by funding from\nthe European Union's 7th Framework Programme via Project RADIANT, NIH\nNHGRI R01-HG009937, and by a CZI EOSS award.\n\n**ELIXIR feedback:** Your feedback matters! Please take our quick user\nsatisfaction survey:\n[link](https://de.surveymonkey.com/r/denbi-service?sc=hd-hub&tool=deseq2)\n:::\n\n::: {#input-data .section .level2}\n## Input data\n\n::: {#why-un-normalized-counts .section .level3}\n### Why un-normalized counts?\n\nAs input, the DESeq2 package expects count data as obtained, e.g., from\nRNA-seq or another high-throughput sequencing experiment, in the form of\na matrix of integer values. The value in the *i*-th row and the *j*-th\ncolumn of the matrix tells how many reads can be assigned to gene *i* in\nsample *j*. Analogously, for other types of assays, the rows of the\nmatrix might correspond e.g.\u00a0to binding regions (with ChIP-Seq) or\npeptide sequences (with quantitative mass spectrometry). We will list\nmethod for obtaining count matrices in sections below.\n\nThe values in the matrix should be un-normalized counts or estimated\ncounts of sequencing reads (for single-end RNA-seq) or fragments (for\npaired-end RNA-seq). The [RNA-seq\nworkflow](http://www.bioconductor.org/help/workflows/rnaseqGene/)\ndescribes multiple techniques for preparing such count matrices. It is\nimportant to provide count matrices as input for DESeq2's statistical\nmodel [(Love, Huber, and Anders 2014)]{.citation} to hold, as only the\ncount values allow assessing the measurement precision correctly. The\nDESeq2 model internally corrects for library size, so transformed or\nnormalized values such as counts scaled by library size should not be\nused as input.\n:::\n\n::: {#the-deseqdataset .section .level3}\n### The DESeqDataSet\n\nThe object class used by the DESeq2 package to store the read counts and\nthe intermediate estimated quantities during statistical analysis is the\n*DESeqDataSet*, which will usually be represented in the code here as an\nobject `dds`.\n\nA technical detail is that the *DESeqDataSet* class extends the\n*RangedSummarizedExperiment* class of the\n[SummarizedExperiment](http://bioconductor.org/packages/SummarizedExperiment)\npackage. The \"Ranged\" part refers to the fact that the rows of the assay\ndata (here, the counts) can be associated with genomic ranges (the exons\nof genes). This association facilitates downstream exploration of\nresults, making use of other Bioconductor packages' range-based\nfunctionality (e.g.\u00a0find the closest ChIP-seq peaks to the\ndifferentially expressed genes).\n\nA *DESeqDataSet* object must have an associated *design formula*. The\ndesign formula expresses the variables which will be used in modeling.\nThe formula should be a tilde (\\~) followed by the variables with plus\nsigns between them (it will be coerced into an *formula* if it is not\nalready). The design can be changed later, however then all differential\nanalysis steps should be repeated, as the design formula is used to\nestimate the dispersions and to estimate the log2 fold changes of the\nmodel.\n\n*Note*: In order to benefit from the default settings of the package,\nyou should put the variable of interest at the end of the formula and\nmake sure the control level is the first level.\n\nWe will now show 4 ways of constructing a *DESeqDataSet*, depending on\nwhat pipeline was used upstream of DESeq2 to generated counts or\nestimated counts:\n\n1.  From [transcript abundance files and tximport](#tximport)\n2.  From a [count matrix](#countmat)\n3.  From [htseq-count files](#htseq)\n4.  From a [SummarizedExperiment](#se) object\n\n[]{#tximport}\n:::\n\n::: {#transcript-abundance-files-and-tximport-tximeta .section .level3}\n### Transcript abundance files and *tximport* / *tximeta*\n\nOur recommended pipeline for *DESeq2* is to use fast transcript\nabundance quantifiers upstream of DESeq2, and then to create gene-level\ncount matrices for use with DESeq2 by importing the quantification data\nusing [tximport](http://bioconductor.org/packages/tximport) [(Soneson,\nLove, and Robinson 2015)]{.citation}. This workflow allows users to\nimport transcript abundance estimates from a variety of external\nsoftware, including the following methods:\n\n-   [Salmon](http://combine-lab.github.io/salmon/) [(Patro et al.\n    2017)]{.citation}\n-   [Sailfish](http://www.cs.cmu.edu/~ckingsf/software/sailfish/)\n    [(Patro, Mount, and Kingsford 2014)]{.citation}\n-   [kallisto](https://pachterlab.github.io/kallisto/about.html) [(Bray\n    et al. 2016)]{.citation}\n-   [RSEM](http://deweylab.github.io/RSEM/) [(Li and Dewey\n    2011)]{.citation}\n\nSome advantages of using the above methods for transcript abundance\nestimation are: (i) this approach corrects for potential changes in gene\nlength across samples (e.g.\u00a0from differential isoform usage) [(Trapnell\net al. 2013)]{.citation}, (ii) some of these methods (*Salmon*,\n*Sailfish*, *kallisto*) are substantially faster and require less memory\nand disk usage compared to alignment-based methods that require creation\nand storage of BAM files, and (iii) it is possible to avoid discarding\nthose fragments that can align to multiple genes with homologous\nsequence, thus increasing sensitivity [(Robert and Watson\n2015)]{.citation}.\n\nFull details on the motivation and methods for importing transcript\nlevel abundance and count estimates, summarizing to gene-level count\nmatrices and producing an offset which corrects for potential changes in\naverage transcript length across samples are described in [(Soneson,\nLove, and Robinson 2015)]{.citation}. Note that the tximport-to-DESeq2\napproach uses *estimated* gene counts from the transcript abundance\nquantifiers, but not *normalized* counts.\n\nA tutorial on how to use the *Salmon* software for quantifying\ntranscript abundance can be found\n[here](https://combine-lab.github.io/salmon/getting_started/). We\nrecommend using the `--gcBias`\n[flag](http://salmon.readthedocs.io/en/latest/salmon.html#gcbias) which\nestimates a correction factor for systematic biases commonly present in\nRNA-seq data [(Love, Hogenesch, and Irizarry 2016; Patro et al.\n2017)]{.citation}, unless you are certain that your data do not contain\nsuch bias.\n\nHere, we demonstrate how to import transcript abundances and construct a\ngene-level *DESeqDataSet* object from *Salmon* `quant.sf` files, which\nare stored in the\n[tximportData](http://bioconductor.org/packages/tximportData) package.\nYou do not need the `tximportData` package for your analysis, it is only\nused here for demonstration.\n\nNote that, instead of locating `dir` using *system.file*, a user would\ntypically just provide a path, e.g.\u00a0`/path/to/quant/files`. For a\ntypical use, the `condition` information should already be present as a\ncolumn of the sample table `samples`, while here we construct artificial\ncondition labels for demonstration.\n\n::: {#cb2 .sourceCode}\n``` {.sourceCode .r}\nlibrary(\"tximport\")\nlibrary(\"readr\")\nlibrary(\"tximportData\")\ndir <- system.file(\"extdata\", package=\"tximportData\")\nsamples <- read.table(file.path(dir,\"samples.txt\"), header=TRUE)\nsamples$condition <- factor(rep(c(\"A\",\"B\"),each=3))\nrownames(samples) <- samples$run\nsamples[,c(\"pop\",\"center\",\"run\",\"condition\")]\n```\n:::\n\n    ##           pop center       run condition\n    ## ERR188297 TSI  UNIGE ERR188297         A\n    ## ERR188088 TSI  UNIGE ERR188088         A\n    ## ERR188329 TSI  UNIGE ERR188329         A\n    ## ERR188288 TSI  UNIGE ERR188288         B\n    ## ERR188021 TSI  UNIGE ERR188021         B\n    ## ERR188356 TSI  UNIGE ERR188356         B\n\nNext we specify the path to the files using the appropriate columns of\n`samples`, and we read in a table that links transcripts to genes for\nthis dataset.\n\n::: {#cb4 .sourceCode}\n``` {.sourceCode .r}\nfiles <- file.path(dir,\"salmon\", samples$run, \"quant.sf.gz\")\nnames(files) <- samples$run\ntx2gene <- read_csv(file.path(dir, \"tx2gene.gencode.v27.csv\"))\n```\n:::\n\nWe import the necessary quantification data for DESeq2 using the\n*tximport* function. For further details on use of *tximport*, including\nthe construction of the `tx2gene` table for linking transcripts to genes\nin your dataset, please refer to the\n[tximport](http://bioconductor.org/packages/tximport) package vignette.\n\n::: {#cb5 .sourceCode}\n``` {.sourceCode .r}\ntxi <- tximport(files, type=\"salmon\", tx2gene=tx2gene)\n```\n:::\n\nFinally, we can construct a *DESeqDataSet* from the `txi` object and\nsample information in `samples`.\n\n::: {#cb6 .sourceCode}\n``` {.sourceCode .r}\nlibrary(\"DESeq2\")\nddsTxi <- DESeqDataSetFromTximport(txi,\n                                   colData = samples,\n                                   design = ~ condition)\n```\n:::\n\nThe `ddsTxi` object here can then be used as `dds` in the following\nanalysis steps.\n:::\n\n::: {#tximeta-for-import-with-automatic-metadata .section .level3}\n### Tximeta for import with automatic metadata\n\nAnother Bioconductor package,\n[tximeta](https://bioconductor.org/packages/tximeta) [(Love et al.\n2020)]{.citation}, extends *tximport*, offering the same functionality,\nplus the additional benefit of automatic addition of annotation metadata\nfor commonly used transcriptomes (GENCODE, Ensembl, RefSeq for human and\nmouse). See the [tximeta](https://bioconductor.org/packages/tximeta)\npackage vignette for more details. *tximeta* produces a\n*SummarizedExperiment* that can be loaded easily into *DESeq2* using the\n`DESeqDataSet` function, with an example in the *tximeta* package\nvignette, and below:\n\n::: {#cb7 .sourceCode}\n``` {.sourceCode .r}\ncoldata <- samples\ncoldata$files <- files\ncoldata$names <- coldata$run\n```\n:::\n\n::: {#cb8 .sourceCode}\n``` {.sourceCode .r}\nlibrary(\"tximeta\")\nse <- tximeta(coldata)\nddsTxi <- DESeqDataSet(se, design = ~ condition)\n```\n:::\n\nThe `ddsTxi` object here can then be used as `dds` in the following\nanalysis steps. If *tximeta* recognized the reference transcriptome as\none of those with a pre-computed hashed checksum, the `rowRanges` of the\n`dds` object will be pre-populated. Again, see the *tximeta* vignette\nfor full details.\n\n[]{#countmat}\n:::\n\n::: {#count-matrix-input .section .level3}\n### Count matrix input\n\nAlternatively, the function *DESeqDataSetFromMatrix* can be used if you\nalready have a matrix of read counts prepared from another source.\nAnother method for quickly producing count matrices from alignment files\nis the *featureCounts* function [(Liao, Smyth, and Shi 2013)]{.citation}\nin the [Rsubread](http://bioconductor.org/packages/Rsubread) package. To\nuse *DESeqDataSetFromMatrix*, the user should provide the counts matrix,\nthe information about the samples (the columns of the count matrix) as a\n*DataFrame* or *data.frame*, and the design formula.\n\nTo demonstrate the use of *DESeqDataSetFromMatrix*, we will read in\ncount data from the [pasilla](http://bioconductor.org/packages/pasilla)\npackage, which have been copied into the *DESeq2* package in the\n`inst/extdata` directory, or the `extdata` directory for the installed\npackage. We read in a count matrix, which we will name `cts`, and the\nsample information table, which we will name `coldata`. Further below we\ndescribe how to extract these objects from, e.g.\u00a0*featureCounts* output.\n\n::: {#cb9 .sourceCode}\n``` {.sourceCode .r}\nlibrary(\"DESeq2\")\npasCts <- system.file(\"extdata\",\n                      \"pasilla_gene_counts.tsv.gz\",\n                      package=\"DESeq2\", mustWork=TRUE)\npasAnno <- system.file(\"extdata\",\n                       \"pasilla_sample_annotation.csv\",\n                       package=\"DESeq2\", mustWork=TRUE)\ncts <- as.matrix(read.csv(pasCts,sep=\"\\t\",row.names=\"gene_id\"))\ncoldata <- read.csv(pasAnno, row.names=1)\ncoldata <- coldata[,c(\"condition\",\"type\")]\ncoldata$condition <- factor(coldata$condition)\ncoldata$type <- factor(coldata$type)\n```\n:::\n\nWe examine the count matrix and column data to see if they are\nconsistent in terms of sample order.\n\n::: {#cb10 .sourceCode}\n``` {.sourceCode .r}\nhead(cts,2)\n```\n:::\n\n    ##             untreated1 untreated2 untreated3 untreated4 treated1 treated2\n    ## FBgn0000003          0          0          0          0        0        0\n    ## FBgn0000008         92        161         76         70      140       88\n    ##             treated3\n    ## FBgn0000003        1\n    ## FBgn0000008       70\n\n::: {#cb12 .sourceCode}\n``` {.sourceCode .r}\ncoldata\n```\n:::\n\n    ##              condition        type\n    ## treated1fb     treated single-read\n    ## treated2fb     treated  paired-end\n    ## treated3fb     treated  paired-end\n    ## untreated1fb untreated single-read\n    ## untreated2fb untreated single-read\n    ## untreated3fb untreated  paired-end\n    ## untreated4fb untreated  paired-end\n\nNote that these are not in the same order with respect to samples!\n\nIt is absolutely critical that the columns of the count matrix and the\nrows of the column data (information about samples) are in the same\norder. DESeq2 will not make guesses as to which column of the count\nmatrix belongs to which row of the column data, these must be provided\nto DESeq2 already in consistent order.\n\nAs they are not in the correct order as given, we need to re-arrange one\nor the other so that they are consistent in terms of sample order (if we\ndo not, later functions would produce an error). We additionally need to\nchop off the `\"fb\"` of the row names of `coldata`, so the naming is\nconsistent.\n\n::: {#cb14 .sourceCode}\n``` {.sourceCode .r}\nrownames(coldata) <- sub(\"fb\", \"\", rownames(coldata))\nall(rownames(coldata) %in% colnames(cts))\n```\n:::\n\n    ## [1] TRUE\n\n::: {#cb16 .sourceCode}\n``` {.sourceCode .r}\nall(rownames(coldata) == colnames(cts))\n```\n:::\n\n    ## [1] FALSE\n\n::: {#cb18 .sourceCode}\n``` {.sourceCode .r}\ncts <- cts[, rownames(coldata)]\nall(rownames(coldata) == colnames(cts))\n```\n:::\n\n    ## [1] TRUE\n\nIf you have used the *featureCounts* function [(Liao, Smyth, and Shi\n2013)]{.citation} in the\n[Rsubread](http://bioconductor.org/packages/Rsubread) package, the\nmatrix of read counts can be directly provided from the `\"counts\"`\nelement in the list output. The count matrix and column data can\ntypically be read into R from flat files using base R functions such as\n*read.csv* or *read.delim*. For *htseq-count* files, see the dedicated\ninput function below.\n\nWith the count matrix, `cts`, and the sample information, `coldata`, we\ncan construct a *DESeqDataSet*:\n\n::: {#cb20 .sourceCode}\n``` {.sourceCode .r}\nlibrary(\"DESeq2\")\ndds <- DESeqDataSetFromMatrix(countData = cts,\n                              colData = coldata,\n                              design = ~ condition)\ndds\n```\n:::\n\n    ## class: DESeqDataSet \n    ## dim: 14599 7 \n    ## metadata(1): version\n    ## assays(1): counts\n    ## rownames(14599): FBgn0000003 FBgn0000008 ... FBgn0261574 FBgn0261575\n    ## rowData names(0):\n    ## colnames(7): treated1 treated2 ... untreated3 untreated4\n    ## colData names(2): condition type\n\nIf you have additional feature data, it can be added to the\n*DESeqDataSet* by adding to the metadata columns of a newly constructed\nobject. (Here we add redundant data just for demonstration, as the gene\nnames are already the rownames of the `dds`.)\n\n::: {#cb22 .sourceCode}\n``` {.sourceCode .r}\nfeatureData <- data.frame(gene=rownames(cts))\nmcols(dds) <- DataFrame(mcols(dds), featureData)\nmcols(dds)\n```\n:::\n\n    ## DataFrame with 14599 rows and 1 column\n    ##                    gene\n    ##             <character>\n    ## FBgn0000003 FBgn0000003\n    ## FBgn0000008 FBgn0000008\n    ## FBgn0000014 FBgn0000014\n    ## FBgn0000015 FBgn0000015\n    ## FBgn0000017 FBgn0000017\n    ## ...                 ...\n    ## FBgn0261571 FBgn0261571\n    ## FBgn0261572 FBgn0261572\n    ## FBgn0261573 FBgn0261573\n    ## FBgn0261574 FBgn0261574\n    ## FBgn0261575 FBgn0261575\n\n[]{#htseq}\n:::\n\n::: {#htseq-count-input .section .level3}\n### *htseq-count* input\n\nYou can use the function *DESeqDataSetFromHTSeqCount* if you have used\n*htseq-count* from the\n[HTSeq](http://www-huber.embl.de/users/anders/HTSeq) python package\n[(Anders, Pyl, and Huber 2014)]{.citation}. For an example of using the\npython scripts, see the\n[pasilla](http://bioconductor.org/packages/pasilla) data package. First\nyou will want to specify a variable which points to the directory in\nwhich the *htseq-count* output files are located.\n\n::: {#cb24 .sourceCode}\n``` {.sourceCode .r}\ndirectory <- \"/path/to/your/files/\"\n```\n:::\n\nHowever, for demonstration purposes only, the following code points to\nthe directory for the demo *htseq-count* output files packages for the\n[pasilla](http://bioconductor.org/packages/pasilla) package.\n\nWe specify which files to read in using *list.files*, and select those\nfiles which contain the string `\"treated\"` using *grep*. The *sub*\nfunction is used to chop up the sample filename to obtain the condition\nstatus, or you might alternatively read in a phenotypic table using\n*read.table*.\n\n::: {#cb25 .sourceCode}\n``` {.sourceCode .r}\n# un-evaluated\ndirectory <- system.file(\"extdata\", package=\"pasilla\",\n                         mustWork=TRUE)\nsampleFiles <- grep(\"treated\",list.files(directory),value=TRUE)\nsampleCondition <- sub(\"(.*treated).*\",\"\\\\1\",sampleFiles)\nsampleTable <- data.frame(sampleName = sampleFiles,\n                          fileName = sampleFiles,\n                          condition = sampleCondition)\nsampleTable$condition <- factor(sampleTable$condition)\nlibrary(\"DESeq2\")\nddsHTSeq <- DESeqDataSetFromHTSeqCount(sampleTable = sampleTable,\n                                       directory = directory,\n                                       design= ~ condition)\nddsHTSeq\n```\n:::\n\n[]{#se}\n:::\n\n::: {#summarizedexperiment-input .section .level3}\n### *SummarizedExperiment* input\n\nIf one has already created or obtained a *SummarizedExperiment*, it can\nbe easily input into DESeq2 as follows. First we load the package\ncontaining the `airway` dataset.\n\n::: {#cb26 .sourceCode}\n``` {.sourceCode .r}\nlibrary(\"airway\")\ndata(\"airway\")\nse <- airway\n```\n:::\n\nThe constructor function below shows the generation of a *DESeqDataSet*\nfrom a *RangedSummarizedExperiment* `se`.\n\n::: {#cb27 .sourceCode}\n``` {.sourceCode .r}\nlibrary(\"DESeq2\")\nddsSE <- DESeqDataSet(se, design = ~ cell + dex)\nddsSE\n```\n:::\n\n    ## class: DESeqDataSet \n    ## dim: 63677 8 \n    ## metadata(2): '' version\n    ## assays(1): counts\n    ## rownames(63677): ENSG00000000003 ENSG00000000005 ... ENSG00000273492\n    ##   ENSG00000273493\n    ## rowData names(10): gene_id gene_name ... seq_coord_system symbol\n    ## colnames(8): SRR1039508 SRR1039509 ... SRR1039520 SRR1039521\n    ## colData names(9): SampleName cell ... Sample BioSample\n:::\n\n::: {#pre-filtering .section .level3}\n### Pre-filtering\n\nWhile it is not necessary to pre-filter low count genes before running\nthe DESeq2 functions, there are two reasons which make pre-filtering\nuseful: by removing rows in which there are very few reads, we reduce\nthe memory size of the `dds` data object, and we increase the speed of\ncount modeling within DESeq2. It can also improve visualizations, as\nfeatures with no information for differential expression are not plotted\nin dispersion plots or MA-plots.\n\nHere we perform pre-filtering to keep only rows that have a count of at\nleast 10 for a minimal number of samples. The count of 10 is a\nreasonable choice for bulk RNA-seq. A recommendation for the minimal\nnumber of samples is to specify the smallest group size, e.g.\u00a0here there\nare 3 treated samples. If there are not discrete groups, one can use the\nminimal number of samples where non-zero counts would be considered\ninteresting. One can also omit this step entirely and just rely on the\nindependent filtering procedures available in `results()`, either *IHW*\nor *genefilter*. See [independent filtering](#indfilt) section.\n\n::: {#cb29 .sourceCode}\n``` {.sourceCode .r}\nsmallestGroupSize <- 3\nkeep <- rowSums(counts(dds) >= 10) >= smallestGroupSize\ndds <- dds[keep,]\n```\n:::\n\n[]{#factorlevels}\n:::\n\n::: {#note-on-factor-levels .section .level3}\n### Note on factor levels\n\nBy default, R will choose a *reference level* for factors based on\nalphabetical order. Then, if you never tell the DESeq2 functions which\nlevel you want to compare against (e.g.\u00a0which level represents the\ncontrol group), the comparisons will be based on the alphabetical order\nof the levels. There are two solutions: you can either explicitly tell\n*results* which comparison to make using the `contrast` argument (this\nwill be shown later), or you can explicitly set the factors levels. In\norder to see the change of reference levels reflected in the results\nnames, you need to either run `DESeq` or `nbinomWaldTest`/`nbinomLRT`\nafter the re-leveling operation. Setting the factor levels can be done\nin two ways, either using factor:\n\n::: {#cb30 .sourceCode}\n``` {.sourceCode .r}\ndds$condition <- factor(dds$condition, levels = c(\"untreated\",\"treated\"))\n```\n:::\n\n...or using *relevel*, just specifying the reference level:\n\n::: {#cb31 .sourceCode}\n``` {.sourceCode .r}\ndds$condition <- relevel(dds$condition, ref = \"untreated\")\n```\n:::\n\nIf you need to subset the columns of a *DESeqDataSet*, i.e., when\nremoving certain samples from the analysis, it is possible that all the\nsamples for one or more levels of a variable in the design formula would\nbe removed. In this case, the *droplevels* function can be used to\nremove those levels which do not have samples in the current\n*DESeqDataSet*:\n\n::: {#cb32 .sourceCode}\n``` {.sourceCode .r}\ndds$condition <- droplevels(dds$condition)\n```\n:::\n:::\n\n::: {#collapsing-technical-replicates .section .level3}\n### Collapsing technical replicates\n\nDESeq2 provides a function *collapseReplicates* which can assist in\ncombining the counts from technical replicates into single columns of\nthe count matrix. The term *technical replicate* implies multiple\nsequencing runs of the same library. You should not collapse biological\nreplicates using this function. See the manual page for an example of\nthe use of *collapseReplicates*.\n:::\n\n::: {#about-the-pasilla-dataset .section .level3}\n### About the pasilla dataset\n\nWe continue with the [pasilla](http://bioconductor.org/packages/pasilla)\ndata constructed from the count matrix method above. This data set is\nfrom an experiment on *Drosophila melanogaster* cell cultures and\ninvestigated the effect of RNAi knock-down of the splicing factor\n*pasilla* [(Brooks et al. 2011)]{.citation}. The detailed transcript of\nthe production of the\n[pasilla](http://bioconductor.org/packages/pasilla) data is provided in\nthe vignette of the data package\n[pasilla](http://bioconductor.org/packages/pasilla).\n\n[]{#de}\n:::\n:::\n\n::: {#differential-expression-analysis .section .level2}\n## Differential expression analysis\n\nThe standard differential expression analysis steps are wrapped into a\nsingle function, *DESeq*. The estimation steps performed by this\nfunction are described [below](#theory), in the manual page for `?DESeq`\nand in the Methods section of the DESeq2 publication [(Love, Huber, and\nAnders 2014)]{.citation}.\n\nResults tables are generated using the function *results*, which\nextracts a results table with log2 fold changes, *p* values and adjusted\n*p* values. With no additional arguments to *results*, the log2 fold\nchange and Wald test *p* value will be for the **last variable** in the\ndesign formula, and if this is a factor, the comparison will be the\n**last level** of this variable over the **reference level** (see\nprevious [note on factor levels](#factorlevels)). However, the order of\nthe variables of the design do not matter so long as the user specifies\nthe comparison to build a results table for, using the `name` or\n`contrast` arguments of *results*.\n\nDetails about the comparison are printed to the console, directly above\nthe results table. The text, `condition treated vs untreated`, tells you\nthat the estimates are of the logarithmic fold change\nlog2(treated/untreated).\n\n::: {#cb33 .sourceCode}\n``` {.sourceCode .r}\ndds <- DESeq(dds)\nres <- results(dds)\nres\n```\n:::\n\n    ## log2 fold change (MLE): condition treated vs untreated \n    ## Wald test p-value: condition treated vs untreated \n    ## DataFrame with 8148 rows and 6 columns\n    ##               baseMean log2FoldChange     lfcSE       stat    pvalue      padj\n    ##              <numeric>      <numeric> <numeric>  <numeric> <numeric> <numeric>\n    ## FBgn0000008   95.28865     0.00399148  0.225010  0.0177391 0.9858470  0.996699\n    ## FBgn0000017 4359.09632    -0.23842494  0.127094 -1.8759764 0.0606585  0.289604\n    ## FBgn0000018  419.06811    -0.10185506  0.146568 -0.6949338 0.4870968  0.822681\n    ## FBgn0000024    6.41105     0.21429657  0.691557  0.3098756 0.7566555  0.939146\n    ## FBgn0000032  990.79225    -0.08896298  0.146253 -0.6082822 0.5430003  0.848881\n    ## ...                ...            ...       ...        ...       ...       ...\n    ## FBgn0261564   1160.028     -0.0857255  0.108354 -0.7911643 0.4288481  0.789246\n    ## FBgn0261565    620.388     -0.2943294  0.140496 -2.0949303 0.0361772  0.206423\n    ## FBgn0261570   3212.969      0.2971841  0.126742  2.3447877 0.0190379  0.133380\n    ## FBgn0261573   2243.936      0.0146611  0.111365  0.1316493 0.8952617  0.977565\n    ## FBgn0261574   4863.807      0.0179729  0.194137  0.0925784 0.9262385  0.986726\n\nNote that we could have specified the coefficient or contrast we want to\nbuild a results table for, using either of the following equivalent\ncommands:\n\n::: {#cb35 .sourceCode}\n``` {.sourceCode .r}\nres <- results(dds, name=\"condition_treated_vs_untreated\")\nres <- results(dds, contrast=c(\"condition\",\"treated\",\"untreated\"))\n```\n:::\n\nOne exception to the equivalence of these two commands, is that, using\n`contrast` will additionally set to 0 the estimated LFC in a comparison\nof two groups, where all of the counts in the two groups are equal to 0\n(while other groups have positive counts). As this may be a desired\nfeature to have the LFC in these cases set to 0, one can use `contrast`\nto build these results tables. More information about extracting\nspecific coefficients from a fitted *DESeqDataSet* object can be found\nin the help page `?results`. The use of the `contrast` argument is also\nfurther discussed [below](#contrasts).\n\n[]{#lfcShrink}\n\n::: {#log-fold-change-shrinkage-for-visualization-and-ranking .section .level3}\n### Log fold change shrinkage for visualization and ranking\n\nShrinkage of effect size (LFC estimates) is useful for visualization and\nranking of genes. To shrink the LFC, we pass the `dds` object to the\nfunction `lfcShrink`. Below we specify to use the *apeglm* method for\neffect size shrinkage [(Zhu, Ibrahim, and Love 2018)]{.citation}, which\nimproves on the previous estimator.\n\nWe provide the `dds` object and the name or number of the coefficient we\nwant to shrink, where the number refers to the order of the coefficient\nas it appears in `resultsNames(dds)`.\n\n::: {#cb36 .sourceCode}\n``` {.sourceCode .r}\nresultsNames(dds)\n```\n:::\n\n    ## [1] \"Intercept\"                      \"condition_treated_vs_untreated\"\n\n::: {#cb38 .sourceCode}\n``` {.sourceCode .r}\nresLFC <- lfcShrink(dds, coef=\"condition_treated_vs_untreated\", type=\"apeglm\")\nresLFC\n```\n:::\n\n    ## log2 fold change (MAP): condition treated vs untreated \n    ## Wald test p-value: condition treated vs untreated \n    ## DataFrame with 8148 rows and 5 columns\n    ##               baseMean log2FoldChange     lfcSE    pvalue      padj\n    ##              <numeric>      <numeric> <numeric> <numeric> <numeric>\n    ## FBgn0000008   95.28865     0.00195376  0.152654 0.9858470  0.996699\n    ## FBgn0000017 4359.09632    -0.18810628  0.120870 0.0606585  0.289604\n    ## FBgn0000018  419.06811    -0.06893831  0.122805 0.4870968  0.822681\n    ## FBgn0000024    6.41105     0.01786546  0.199499 0.7566555  0.939146\n    ## FBgn0000032  990.79225    -0.06001511  0.121962 0.5430003  0.848881\n    ## ...                ...            ...       ...       ...       ...\n    ## FBgn0261564   1160.028     -0.0669829 0.0976567 0.4288481  0.789246\n    ## FBgn0261565    620.388     -0.2284564 0.1362122 0.0361772  0.206423\n    ## FBgn0261570   3212.969      0.2395981 0.1237304 0.0190379  0.133380\n    ## FBgn0261573   2243.936      0.0115395 0.0981689 0.8952617  0.977565\n    ## FBgn0261574   4863.807      0.0101618 0.1417667 0.9262385  0.986726\n\nShrinkage estimation is discussed more in a [later section](#altshrink).\n\n[]{#parallel}\n:::\n\n::: {#speed-up-and-parallelization-thoughts .section .level3}\n### Speed-up and parallelization thoughts\n\nThe above steps should take less than 30 seconds for most analyses. For\nexperiments with complex designs and many samples (e.g.\u00a0dozens of\ncoefficients, \\~100s of samples), one may want to have faster\ncomputation than provided by the default run of `DESeq`. We have two\nrecommendations:\n\n1.  By using the argument `fitType=\"glmGamPoi\"`, one can leverage the\n    faster NB GLM engine written by Constantin Ahlmann-Eltze. Note that\n    glmGamPoi's interface in DESeq2 requires use of `test=\"LRT\"` and\n    specification of a `reduced` design.\n\n2.  One can take advantage of parallelized computation. Parallelizing\n    `DESeq`, `results`, and `lfcShrink` can be easily accomplished by\n    loading the BiocParallel package, and then setting the following\n    arguments: `parallel=TRUE` and `BPPARAM=MulticoreParam(4)`, for\n    example, splitting the job over 4 cores. However, some words of\n    advice on parallelization: first, it is recommend to filter genes\n    where all samples have low counts, to avoid sending data\n    unnecessarily to child processes, when those genes have low power\n    and will be independently filtered anyway; secondly, there is often\n    diminishing returns for adding more cores due to overhead of sending\n    data to child processes, therefore I recommend first starting with\n    small number of additional cores. Note that obtaining `results` for\n    coefficients or contrasts listed in `resultsNames(dds)` is fast and\n    will not need parallelization. As an alternative to `BPPARAM`, one\n    can `register` cores at the beginning of an analysis, and then just\n    specify `parallel=TRUE` to the functions when called.\n\n::: {#cb40 .sourceCode}\n``` {.sourceCode .r}\nlibrary(\"BiocParallel\")\nregister(MulticoreParam(4))\n```\n:::\n:::\n\n::: {#p-values-and-adjusted-p-values .section .level3}\n### p-values and adjusted p-values\n\nWe can order our results table by the smallest *p* value:\n\n::: {#cb41 .sourceCode}\n``` {.sourceCode .r}\nresOrdered <- res[order(res$pvalue),]\n```\n:::\n\nWe can summarize some basic tallies using the *summary* function.\n\n::: {#cb42 .sourceCode}\n``` {.sourceCode .r}\nsummary(res)\n```\n:::\n\n    ## \n    ## out of 8148 with nonzero total read count\n    ## adjusted p-value < 0.1\n    ## LFC > 0 (up)       : 533, 6.5%\n    ## LFC < 0 (down)     : 536, 6.6%\n    ## outliers [1]       : 0, 0%\n    ## low counts [2]     : 0, 0%\n    ## (mean count < 5)\n    ## [1] see 'cooksCutoff' argument of ?results\n    ## [2] see 'independentFiltering' argument of ?results\n\nHow many adjusted p-values were less than 0.1?\n\n::: {#cb44 .sourceCode}\n``` {.sourceCode .r}\nsum(res$padj < 0.1, na.rm=TRUE)\n```\n:::\n\n    ## [1] 1069\n\nThe *results* function contains a number of arguments to customize the\nresults table which is generated. You can read about these arguments by\nlooking up `?results`. Note that the *results* function automatically\nperforms independent filtering based on the mean of normalized counts\nfor each gene, optimizing the number of genes which will have an\nadjusted *p* value below a given FDR cutoff, `alpha`. Independent\nfiltering is further discussed [below](#indfilt). By default the\nargument `alpha` is set to [\\\\(0.1\\\\)]{.math .inline}. If the adjusted\n*p* value cutoff will be a value other than [\\\\(0.1\\\\)]{.math .inline},\n`alpha` should be set to that value:\n\n::: {#cb46 .sourceCode}\n``` {.sourceCode .r}\nres05 <- results(dds, alpha=0.05)\nsummary(res05)\n```\n:::\n\n    ## \n    ## out of 8148 with nonzero total read count\n    ## adjusted p-value < 0.05\n    ## LFC > 0 (up)       : 416, 5.1%\n    ## LFC < 0 (down)     : 437, 5.4%\n    ## outliers [1]       : 0, 0%\n    ## low counts [2]     : 0, 0%\n    ## (mean count < 5)\n    ## [1] see 'cooksCutoff' argument of ?results\n    ## [2] see 'independentFiltering' argument of ?results\n\n::: {#cb48 .sourceCode}\n``` {.sourceCode .r}\nsum(res05$padj < 0.05, na.rm=TRUE)\n```\n:::\n\n    ## [1] 853\n\n[]{#IHW}\n:::\n\n::: {#independent-hypothesis-weighting .section .level3}\n### Independent hypothesis weighting\n\nA generalization of the idea of *p* value filtering is to *weight*\nhypotheses to optimize power. A Bioconductor package,\n[IHW](http://bioconductor.org/packages/IHW), is available that\nimplements the method of *Independent Hypothesis Weighting* [(Ignatiadis\net al. 2016)]{.citation}. Here we show the use of *IHW* for *p* value\nadjustment of DESeq2 results. For more details, please see the vignette\nof the [IHW](http://bioconductor.org/packages/IHW) package. The *IHW*\nresult object is stored in the metadata.\n\n**Note:** If the results of independent hypothesis weighting are used in\npublished research, please cite:\n\n> Ignatiadis, N., Klaus, B., Zaugg, J.B., Huber, W. (2016) Data-driven\n> hypothesis weighting increases detection power in genome-scale\n> multiple testing. *Nature Methods*, **13**:7.\n> [10.1038/nmeth.3885](http://dx.doi.org/10.1038/nmeth.3885)\n\n::: {#cb50 .sourceCode}\n``` {.sourceCode .r}\n# (unevaluated code chunk)\nlibrary(\"IHW\")\nresIHW <- results(dds, filterFun=ihw)\nsummary(resIHW)\nsum(resIHW$padj < 0.1, na.rm=TRUE)\nmetadata(resIHW)$ihwResult\n```\n:::\n\nFor advanced users, note that all the values calculated by the DESeq2\npackage are stored in the *DESeqDataSet* object or the *DESeqResults*\nobject, and access to these values is discussed [below](#access).\n:::\n:::\n\n::: {#exploring-and-exporting-results .section .level2}\n## Exploring and exporting results\n\n::: {#ma-plot .section .level3}\n### MA-plot\n\nIn DESeq2, the function *plotMA* shows the log2 fold changes\nattributable to a given variable over the mean of normalized counts for\nall the samples in the *DESeqDataSet*. Points will be colored blue if\nthe adjusted *p* value is less than 0.1. Points which fall out of the\nwindow are plotted as open triangles pointing either up or down.\n\n::: {#cb51 .sourceCode}\n``` {.sourceCode .r}\nplotMA(res, ylim=c(-2,2))\n```\n:::\n\n![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA8AAAAPACAIAAAB1tIfMAAAACXBIWXMAAB2HAAAdhwGP5fFlAAAgAElEQVR4nOzdd5zUxf3H8dk9OKqIilRREYnYMIq9i8YWFUssiRJbvDPRn1FjTewmtliSGAtriQZiSSzExBh7iV1BURMrUkRBROnl4O7m98eu3/vybTsz3777ej7449j7ltnv7u2+d/YzMwUppQAAAACgpph2AwAAAIA8IUADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgAYCNAAAAKCBAA0AAABoIEADAAAAGgjQAAAAgIZOaTcA0ZsxY8bYsWPb2trSbggAAKh9PXr0+MUvftG9e/e0G5IcAnQNuummm6655pq0WwEAAOrFRhttdMQRR6TdiuQQoGvQypUrhRAHHHDAzjvvnHZbAABALbv//vvfeuutFStWpN2QRBGga9aoUaPOOOOMtFsBAABq2XvvvffWW2+l3YqkMYgQAAAA0ECABgAAADQQoAEAAAANBGgAAABAAwEaAAAA0ECABgAAADQQoAEAAAANBGgAAABAAwEaAAAA0ECABgAAADQQoAEAAAANBGgAAABAQ6e0G5BNK7768K33Pv1yaZf+G3xno6HrrN4YuPXyLz/6aPYyWWjsM3T4oB6FhNoIAA\n\n[Content truncated...]",
      "source": "vignette",
      "edam_match": {
        "edam_id": "http://edamontology.org/operation_2436",
        "edam_label": "Gene-set enrichment analysis",
        "confidence_score": 0.8,
        "reasoning": "The DESeq2 package is primarily used for differential expression analysis of RNA-seq data, which involves identifying genes that are differentially expressed between different conditions. This process is closely related to gene-set enrichment analysis, which identifies classes of genes or proteins that are over or under-represented in a large set of genes or proteins. Although DESeq2 itself does not perform gene-set enrichment analysis, it provides the differential expression results that are often used as input for such analyses. Therefore, the most relevant EDAM ontology term from the provided candidates is \"Gene-set enrichment analysis.\"",
        "validated": true
      }
    }
  ],
  "summary": {
    "total_packages": 4,
    "total_matches": 4,
    "average_confidence": 0,
    "high_confidence_count": 0,
    "low_confidence_count": 0,
    "new_designations_count": 0
  }
}